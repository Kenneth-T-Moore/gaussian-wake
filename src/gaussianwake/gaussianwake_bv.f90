!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.13 (r6665M) - 27 Nov 2017 15:43
!
!  Differentiation of porteagel_analyze in reverse (adjoint) mode:
!   gradient     of useful results: wtvelocity
!   with respect to varying inputs: rotordiameter turbinez turbinexw
!                wtvelocity turbineyw yawdeg ct
!   RW status of diff variables: rotordiameter:out turbinez:out
!                turbinexw:out wtvelocity:in-zero turbineyw:out
!                yawdeg:out ct:out
! Implementation of the Bastankhah and Porte Agel gaussian-shaped wind turbine wake 
! model (2016) with various farm modeling (TI and wake combination) methods included
! Created by Jared J. Thomas, 2017.
! FLight Optimization and Wind Laboratory (FLOW Lab)
! Brigham Young University
! implementation of the Bastankhah and Porte Agel (BPA) wake model for analysis
SUBROUTINE PORTEAGEL_ANALYZE_BV(nturbines, nrotorpoints, nctpoints, &
& turbinexw, turbinexwb, sorted_x_idx, turbineyw, turbineywb, turbinez, &
& turbinezb, rotordiameter, rotordiameterb, ct, ctb, wind_speed, yawdeg&
& , yawdegb, ky, kz, alpha, beta, ti, rotorpointsy, rotorpointsz, z_ref&
& , z_0, shear_exp, wake_combination_method, ti_calculation_method, &
& calc_k_star, opt_exp_fac, print_ti, wake_model_version, interp_type, &
& use_ct_curve, ct_curve_wind_speed, ct_curve_ct, wtvelocity, &
& wtvelocityb, nbdirs)
  !USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
!!  print TIturbs values to a file
!     if (print_ti) then
!         open(unit=2, file="TIturbs_tmp.txt")
!         do, turb=1, nTurbines 
!             write(2,*) TIturbs(turb)
!         end do
!         close(2)
!     end if 
!print *, "TIturbs: ", TIturbs
!print *, wtVelocity
!! make sure turbine inflow velocity is non-negative
!             if (wtVelocity(turbI) .lt. 0.0_dp) then 
!                 wtVelocity(turbI) = 0.0_dp
!             end if
!print *, "fortran"
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  INTEGER, INTENT(IN) :: nturbines, nrotorpoints, nctpoints
  INTEGER, INTENT(IN) :: wake_combination_method, ti_calculation_method&
& , wake_model_version, interp_type
  LOGICAL, INTENT(IN) :: calc_k_star, print_ti, use_ct_curve
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: turbinexw, turbineyw, &
& turbinez
  REAL(dp), DIMENSION(nbdirs, nturbines) :: turbinexwb, turbineywb, &
& turbinezb
  INTEGER, DIMENSION(nturbines), INTENT(IN) :: sorted_x_idx
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: rotordiameter, yawdeg
  REAL(dp), DIMENSION(nbdirs, nturbines) :: rotordiameterb, yawdegb
  REAL(dp), DIMENSION(nturbines) :: ct
  REAL(dp), DIMENSION(nbdirs, nturbines) :: ctb
  REAL(dp), INTENT(IN) :: ky, kz, alpha, beta, ti, wind_speed, z_ref, &
& z_0, shear_exp, opt_exp_fac
  REAL(dp), DIMENSION(nrotorpoints), INTENT(IN) :: rotorpointsy, &
& rotorpointsz
  REAL(dp), DIMENSION(nctpoints), INTENT(IN) :: ct_curve_wind_speed, &
& ct_curve_ct
! local (General)
  REAL(dp), DIMENSION(nturbines) :: yaw, titurbs, ct_local, ky_local, &
& kz_local
  REAL(dp), DIMENSION(nbdirs, nturbines) :: yawb, titurbsb, ct_localb&
& , ky_localb, kz_localb
  REAL(dp) :: x0, deltax0, deltay, theta_c_0, sigmay, sigmaz, &
& wake_offset, k_star
  REAL(dp), DIMENSION(nbdirs) :: x0b, deltax0b, deltayb, theta_c_0b, &
& sigmayb, sigmazb, wake_offsetb, k_starb
  REAL(dp) :: x, deltav, deltaz, sigmay_dp, sigmaz_dp, deltax0_dp, &
& deficit_sum
  REAL(dp), DIMENSION(nbdirs) :: xb, deltavb, deltazb, sigmay_dpb, &
& sigmaz_dpb, deltax0_dpb, deficit_sumb
  REAL(dp) :: tol, discontinuity_point, ti_area_ratio
  REAL(dp), DIMENSION(nbdirs) :: discontinuity_pointb
  REAL(dp) :: ti_area_ratio_tmp, ti_dst_tmp, ti_ust_tmp, rpts
  REAL(dp), DIMENSION(nbdirs) :: ti_dst_tmpb, ti_ust_tmpb
  REAL(dp) :: localrotorpointy, localrotorpointz, point_velocity, &
& point_z, point_velocity_with_shear
  REAL(dp), DIMENSION(nbdirs) :: localrotorpointyb, localrotorpointzb&
& , point_velocityb, point_zb, point_velocity_with_shearb
  INTEGER :: u, d, turb, turbi, p
  REAL(dp), PARAMETER :: pi=3.141592653589793_dp
! model out
  REAL(dp), DIMENSION(nturbines) :: wtvelocity
  REAL(dp), DIMENSION(nbdirs, nturbines) :: wtvelocityb
  INTRINSIC SIN, COS, ATAN, MAX, SQRT, LOG
  INTRINSIC REAL
  INTEGER :: nd
  INTEGER :: branch
  INTEGER :: nbdirs
! bastankhah and porte agel 2016 define yaw to be positive clockwise, this is reversed
  yaw = -(yawdeg*pi/180.0_dp)
! set tolerance for location checks
  tol = 0.1_dp
! initialize wind turbine velocities to 0.0
  wtvelocity = 0.0_dp
! initialize TI of all turbines to free-stream value
!print *, "start TIturbs: ", TIturbs
  titurbs = ti
! initialize the local wake factors
  ky_local(:) = ky
  kz_local(:) = kz
  ct_local(:) = ct
!print *, 'wake model version: ', wake_model_version
!print *, "ky_local: ", ky_local
!print *, "kz_local: ", kz_local
!print *, "TIturbs init: ", TIturbs
  DO d=1,nturbines
! get index of downstream turbine
    CALL PUSHINTEGER4(turbi)
    turbi = sorted_x_idx(d) + 1
    DO p=1,nrotorpoints
! initialize the TI_area_ratio to 0.0 for each turbine
      ti_area_ratio = 0.0_dp
! initialize deficit summation term to zero
      deficit_sum = 0.0_dp
! scale rotor sample point coordinate by rotor diameter (in rotor hub ref. frame)
      localrotorpointy = rotorpointsy(p)*0.5_dp*rotordiameter(turbi)
      localrotorpointz = rotorpointsz(p)*0.5_dp*rotordiameter(turbi)
!             !print *, "rotorDiameter after local rotor points", rotorDiameter
!             !print *, "local rotor points Y,Z: ", LocalRotorPointY, LocalRotorPointZ
! at turbineX-locations
      DO u=1,nturbines
! get index of upstream turbine
        CALL PUSHINTEGER4(turb)
        turb = sorted_x_idx(u) + 1
! skip this loop if turb = turbI (turbines impact on itself)
        IF (turb .EQ. turbi) THEN
          CALL PUSHCONTROL2B(0)
        ELSE
! downstream distance between upstream turbine and point
          CALL PUSHREAL8(x)
          x = turbinexw(turbi) - turbinexw(turb) + localrotorpointy*SIN(&
&           yaw(turbi))
! set this iterations velocity deficit to 0
! check turbine relative locations
          IF (x .GT. 0.0_dp + tol) THEN
!print *, "rotorDiameter before x0 ", rotorDiameter
! determine the onset location of far wake
            CALL PUSHREAL8(x0)
            CALL X0_FUNC(rotordiameter(turb), yaw(turb), ct_local(turb)&
&                  , alpha, titurbs(turb), beta, x0)
!                     call x0_func(rotorDiameter(turb), yaw(turb), Ct(turb), alpha, & 
!                                 & TI, beta, x0)
! downstream distance from far wake onset to downstream turbine
            CALL PUSHREAL8(deltax0)
            deltax0 = x - x0
! calculate wake spreading parameter at each turbine if desired
            IF (calc_k_star .EQV. .true.) THEN
              CALL K_STAR_FUNC(titurbs(turb), k_star)
              CALL PUSHREAL8(ky_local(turb))
              ky_local(turb) = k_star
              CALL PUSHREAL8(kz_local(turb))
              kz_local(turb) = k_star
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
!print *, "ky_local ", ky_local
!print *, "deltax0 ", deltax0
!print *, "turbineZ ", turbineZ
!print *, "rotorDiameter after x0 ", rotorDiameter
!print *, "Ct ", Ct
!print *, "yaw ", yaw
! determine the initial wake angle at the onset of far wake
            CALL PUSHREAL8(theta_c_0)
            CALL THETA_C_0_FUNC(yaw(turb), ct_local(turb), theta_c_0)
!print *, "theta_c_0 ", theta_c_0
! horizontal spread
            CALL PUSHREAL8(sigmay)
            CALL SIGMAY_FUNC(ky_local(turb), deltax0, rotordiameter(turb&
&                      ), yaw(turb), sigmay)
!print *, "sigmay ", sigmay
!print *, "rotorDiameter after sigmay", rotorDiameter
! vertical spread
            CALL PUSHREAL8(sigmaz)
            CALL SIGMAZ_FUNC(kz_local(turb), deltax0, rotordiameter(turb&
&                      ), sigmaz)
!print *, "sigmaz ", sigmaz
!print *, "rotorDiameter after sigmaz ", rotorDiameter
! horizontal cross-wind wake displacement from hub
            CALL WAKE_OFFSET_FUNC(rotordiameter(turb), theta_c_0, x0, &
&                           yaw(turb), ky_local(turb), kz_local(turb), &
&                           ct_local(turb), sigmay, sigmaz, wake_offset)
!print *, "wake_offset ", wake_offset                 
! cross wind distance from downstream point location to wake center
            CALL PUSHREAL8(deltay)
            deltay = localrotorpointy*COS(yaw(turbi)) + turbineyw(turbi)&
&             - (turbineyw(turb)+wake_offset)
! cross wind distance from hub height to height of point of interest
            deltaz = localrotorpointz + turbinez(turbi) - turbinez(turb)
!print *, "dx, dy, dz: ", x, deltay, deltaz
!print *, "local y,z : ", LocalRotorPointY, LocalRotorPointZ, turb, turbI, p
!print *, deltaz, deltay
! far wake region
! find the final point where the original model is undefined
            CALL PUSHREAL8(discontinuity_point)
            CALL DISCONTINUITY_POINT_FUNC(x0, rotordiameter(turb), &
&                                   ky_local(turb), kz_local(turb), yaw(&
&                                   turb), ct_local(turb), &
&                                   discontinuity_point)
            IF (x .GT. discontinuity_point) THEN
!print *, x
! velocity difference in the wake
              CALL PUSHREAL8(deltav)
              CALL DELTAV_FUNC(deltay, deltaz, ct_local(turb), yaw(turb)&
&                        , sigmay, sigmaz, rotordiameter(turb), &
&                        wake_model_version, kz_local(turb), x, &
&                        opt_exp_fac, deltav)
!print *, "rotorDiameter after far deltav ", rotorDiameter
! near wake region (linearized)
              CALL PUSHCONTROL1B(0)
            ELSE
! determine distance from discontinuity point to far wake onset
              CALL PUSHREAL8(deltax0_dp)
              deltax0_dp = discontinuity_point - x0
! horizontal spread at far wake onset
              CALL PUSHREAL8(sigmay_dp)
              CALL SIGMAY_FUNC(ky_local(turb), deltax0_dp, rotordiameter&
&                        (turb), yaw(turb), sigmay_dp)
! vertical spread at far wake onset
              CALL PUSHREAL8(sigmaz_dp)
              CALL SIGMAZ_FUNC(kz_local(turb), deltax0_dp, rotordiameter&
&                        (turb), sigmaz_dp)
!  print *, "inputs in parent: ", deltay, deltaz, Ct(turb), yaw(turb), sigmay_dp, sigmaz_dp, &
!                                          & rotorDiameter(turb), x, discontinuity_point, sigmay_dp, sigmaz_dp, &
!                                          & wake_model_version, kz_local, x0, &
!                                          & opt_exp_fac
! velocity deficit in the nearwake (linear model)
              CALL PUSHREAL8(deltav)
              CALL DELTAV_NEAR_WAKE_LIN_FUNC(deltay, deltaz, ct_local(&
&                                      turb), yaw(turb), sigmay_dp, &
&                                      sigmaz_dp, rotordiameter(turb), x&
&                                      , discontinuity_point, sigmay_dp&
&                                      , sigmaz_dp, wake_model_version, &
&                                      kz_local(turb), x0, opt_exp_fac, &
&                                      deltav)
!print *, "rotorDiameter after deltav near ", rotorDiameter
              CALL PUSHCONTROL1B(1)
            END IF
! combine deficits according to selected method wake combination method
            CALL PUSHREAL8(deficit_sum)
            CALL WAKE_COMBINATION_FUNC(wind_speed, wtvelocity(turb), &
&                                deltav, wake_combination_method, &
&                                deficit_sum)
            IF (x .GT. 0.0_dp .AND. ti_calculation_method .GT. 0) THEN
!print *, "turbI, turb: ", turbI, turb
! calculate TI value at each turbine
!                         print *, "turb, turbI: ", turb, turbI
! save ti_area_ratio and ti_dst to new memory locations to avoid 
! aliasing during differentiation
              CALL PUSHREAL8(ti_area_ratio_tmp)
              ti_area_ratio_tmp = ti_area_ratio
              CALL PUSHREAL8(ti_dst_tmp)
              ti_dst_tmp = titurbs(turbi)
              CALL PUSHREAL8(ti_ust_tmp)
              ti_ust_tmp = titurbs(turb)
              CALL PUSHREAL8(titurbs(turbi))
              CALL ADDED_TI_FUNC(ti, ct_local(turb), x, ky_local(turb), &
&                          rotordiameter(turb), rotordiameter(turbi), &
&                          deltay, turbinez(turb), turbinez(turbi), &
&                          ti_ust_tmp, ti_calculation_method, &
&                          ti_area_ratio_tmp, ti_dst_tmp, ti_area_ratio&
&                          , titurbs(turbi))
!print *, "rotorDiameter after TI calcs", rotorDiameter
              CALL PUSHCONTROL2B(3)
            ELSE
              CALL PUSHCONTROL2B(2)
            END IF
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        END IF
      END DO
!                     !print *, "deficit_sum, turbI, p, turb: ", deficit_sum, turbI, p, turb
! print *, deficit_sum
! find velocity at point p due to the wake of turbine turb
      CALL PUSHREAL8(point_velocity)
      point_velocity = wind_speed - deficit_sum
!print *, "point velocity, deficit_sum, turbI, p: ", point_velocity, deficit_sum, turbI, p    
! put sample point height in global reference frame
      point_z = localrotorpointz + turbinez(turbi)
!print *, "point_z, turbI, p: ", point_z, turbI, p    
! adjust sample point velocity for shear
      CALL WIND_SHEAR_FUNC(point_z, point_velocity, z_ref, z_0, &
&                    shear_exp, point_velocity_with_shear)
!print *, "v, vs, x, turb, turbI, p: ", point_velocity, point_velocity_with_shear, x, turb, turbI, p
! add sample point velocity to turbine velocity to be averaged later
      CALL PUSHREAL8(wtvelocity(turbi))
      wtvelocity(turbi) = wtvelocity(turbi) + point_velocity_with_shear
    END DO
! final velocity calculation for turbine turbI (average equally across all points)
    CALL PUSHREAL8(rpts)
    rpts = REAL(nrotorpoints, dp)
!         print *, rpts, nRotorPoints, wtVelocity(turbI), wtVelocity(turbI)/rpts, wtVelocity(turbI)/nRotorPoints
!         STOP 1
    CALL PUSHREAL8(wtvelocity(turbi))
    wtvelocity(turbi) = wtvelocity(turbi)/rpts
!         print *, wtVelocity(turbI)
    IF (use_ct_curve) THEN
      CALL PUSHREAL8(ct_local(turbi))
      CALL INTERPOLATION(nctpoints, interp_type, ct_curve_wind_speed, &
&                  ct_curve_ct, wtvelocity(turbi), ct_local(turbi))
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
  END DO
  DO nd=1,nbdirs
    rotordiameterb(nd, :) = 0.0_8
    turbinezb(nd, :) = 0.0_8
    turbinexwb(nd, :) = 0.0_8
    turbineywb(nd, :) = 0.0_8
    yawb(nd, :) = 0.0_8
    titurbsb(nd, :) = 0.0_8
    kz_localb(nd, :) = 0.0_8
    ct_localb(nd, :) = 0.0_8
    ky_localb(nd, :) = 0.0_8
  END DO
  DO d=nturbines,1,-1
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      turbi = sorted_x_idx(d) + 1
      CALL POPREAL8(ct_local(turbi))
      CALL INTERPOLATION_BV(nctpoints, interp_type, ct_curve_wind_speed&
&                     , ct_curve_ct, wtvelocity(turbi), wtvelocityb(1, &
&                     turbi), ct_local(turbi), ct_localb(1, turbi), &
&                     nbdirs)
    END IF
    DO nd=1,nbdirs
      wtvelocityb(nd, turbi) = wtvelocityb(nd, turbi)/rpts
    END DO
    CALL POPREAL8(wtvelocity(turbi))
    CALL POPREAL8(rpts)
    DO p=nrotorpoints,1,-1
      DO nd=1,nbdirs
        point_velocity_with_shearb(nd) = wtvelocityb(nd, turbi)
      END DO
      CALL POPREAL8(wtvelocity(turbi))
      localrotorpointz = rotorpointsz(p)*0.5_dp*rotordiameter(turbi)
      point_z = localrotorpointz + turbinez(turbi)
      CALL WIND_SHEAR_FUNC_BV(point_z, point_zb, point_velocity, &
&                       point_velocityb, z_ref, z_0, shear_exp, &
&                       point_velocity_with_shear, &
&                       point_velocity_with_shearb, nbdirs)
      CALL POPREAL8(point_velocity)
      localrotorpointy = rotorpointsy(p)*0.5_dp*rotordiameter(turbi)
      DO nd=1,nbdirs
        localrotorpointzb(nd) = point_zb(nd)
        turbinezb(nd, turbi) = turbinezb(nd, turbi) + point_zb(nd)
        deficit_sumb(nd) = -point_velocityb(nd)
      END DO
      DO nd=1,nbdirs
        localrotorpointyb(nd) = 0.0_8
      END DO
      DO u=nturbines,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) THEN
            GOTO 100
          ELSE
            DO nd=1,nbdirs
              xb(nd) = 0.0_8
            END DO
          END IF
        ELSE
          IF (branch .EQ. 2) THEN
            DO nd=1,nbdirs
              xb(nd) = 0.0_8
              deltayb(nd) = 0.0_8
            END DO
          ELSE
            turb = sorted_x_idx(u) + 1
            CALL POPREAL8(titurbs(turbi))
            CALL ADDED_TI_FUNC_BV(ti, ct_local(turb), ct_localb(1, turb)&
&                           , x, xb, ky_local(turb), ky_localb(1, turb)&
&                           , rotordiameter(turb), rotordiameterb(1, &
&                           turb), rotordiameter(turbi), rotordiameterb(&
&                           1, turbi), deltay, deltayb, turbinez(turb), &
&                           turbinezb(1, turb), turbinez(turbi), &
&                           turbinezb(1, turbi), ti_ust_tmp, ti_ust_tmpb&
&                           , ti_calculation_method, ti_area_ratio_tmp, &
&                           ti_dst_tmp, ti_dst_tmpb, ti_area_ratio, &
&                           titurbs(turbi), titurbsb(1, turbi), nbdirs)
            CALL POPREAL8(ti_ust_tmp)
            CALL POPREAL8(ti_dst_tmp)
            CALL POPREAL8(ti_area_ratio_tmp)
            DO nd=1,nbdirs
              titurbsb(nd, turbi) = 0.0_8
              titurbsb(nd, turb) = titurbsb(nd, turb) + ti_ust_tmpb(nd)
              titurbsb(nd, turbi) = titurbsb(nd, turbi) + ti_dst_tmpb(nd&
&               )
            END DO
          END IF
          CALL POPREAL8(deficit_sum)
          CALL WAKE_COMBINATION_FUNC_BV(wind_speed, wtvelocity(turb), &
&                                 wtvelocityb(1, turb), deltav, deltavb&
&                                 , wake_combination_method, deficit_sum&
&                                 , deficit_sumb, nbdirs)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            deltaz = localrotorpointz + turbinez(turbi) - turbinez(turb)
            CALL POPREAL8(deltav)
            CALL DELTAV_FUNC_BV(deltay, deltayb, deltaz, deltazb, &
&                         ct_local(turb), ct_localb(1, turb), yaw(turb)&
&                         , yawb(1, turb), sigmay, sigmayb, sigmaz, &
&                         sigmazb, rotordiameter(turb), rotordiameterb(1&
&                         , turb), wake_model_version, kz_local(turb), &
&                         kz_localb(1, turb), x, xb, opt_exp_fac, deltav&
&                         , deltavb, nbdirs)
            DO nd=1,nbdirs
              discontinuity_pointb(nd) = 0.0_8
              x0b(nd) = 0.0_8
            END DO
          ELSE
            deltaz = localrotorpointz + turbinez(turbi) - turbinez(turb)
            CALL POPREAL8(deltav)
            CALL DELTAV_NEAR_WAKE_LIN_FUNC_BV(deltay, deltayb, deltaz, &
&                                       deltazb, ct_local(turb), &
&                                       ct_localb(1, turb), yaw(turb), &
&                                       yawb(1, turb), sigmay_dp, &
&                                       sigmay_dpb, sigmaz_dp, &
&                                       sigmaz_dpb, rotordiameter(turb)&
&                                       , rotordiameterb(1, turb), x, xb&
&                                       , discontinuity_point, &
&                                       discontinuity_pointb, sigmay_dp&
&                                       , sigmay_dpb, sigmaz_dp, &
&                                       sigmaz_dpb, wake_model_version, &
&                                       kz_local(turb), kz_localb(1, &
&                                       turb), x0, x0b, opt_exp_fac, &
&                                       deltav, deltavb, nbdirs)
            CALL POPREAL8(sigmaz_dp)
            CALL SIGMAZ_FUNC_BV(kz_local(turb), kz_localb(1, turb), &
&                         deltax0_dp, deltax0_dpb, rotordiameter(turb), &
&                         rotordiameterb(1, turb), sigmaz_dp, sigmaz_dpb&
&                         , nbdirs)
            CALL POPREAL8(sigmay_dp)
            CALL SIGMAY_FUNC_BV(ky_local(turb), ky_localb(1, turb), &
&                         deltax0_dp, deltax0_dpb, rotordiameter(turb), &
&                         rotordiameterb(1, turb), yaw(turb), yawb(1, &
&                         turb), sigmay_dp, sigmay_dpb, nbdirs)
            CALL POPREAL8(deltax0_dp)
            DO nd=1,nbdirs
              discontinuity_pointb(nd) = discontinuity_pointb(nd) + &
&               deltax0_dpb(nd)
              x0b(nd) = x0b(nd) - deltax0_dpb(nd)
            END DO
            DO nd=1,nbdirs
              sigmayb(nd) = 0.0_8
              sigmazb(nd) = 0.0_8
            END DO
          END IF
          CALL POPREAL8(discontinuity_point)
          CALL DISCONTINUITY_POINT_FUNC_BV(x0, x0b, rotordiameter(turb)&
&                                    , rotordiameterb(1, turb), ky_local&
&                                    (turb), ky_localb(1, turb), &
&                                    kz_local(turb), kz_localb(1, turb)&
&                                    , yaw(turb), yawb(1, turb), &
&                                    ct_local(turb), ct_localb(1, turb)&
&                                    , discontinuity_point, &
&                                    discontinuity_pointb, nbdirs)
          CALL POPREAL8(deltay)
          DO nd=1,nbdirs
            localrotorpointzb(nd) = localrotorpointzb(nd) + deltazb(nd)
            turbinezb(nd, turbi) = turbinezb(nd, turbi) + deltazb(nd)
            turbinezb(nd, turb) = turbinezb(nd, turb) - deltazb(nd)
            localrotorpointyb(nd) = localrotorpointyb(nd) + COS(yaw(&
&             turbi))*deltayb(nd)
            yawb(nd, turbi) = yawb(nd, turbi) - localrotorpointy*SIN(yaw&
&             (turbi))*deltayb(nd)
            turbineywb(nd, turbi) = turbineywb(nd, turbi) + deltayb(nd)
            turbineywb(nd, turb) = turbineywb(nd, turb) - deltayb(nd)
            wake_offsetb(nd) = -deltayb(nd)
          END DO
          CALL WAKE_OFFSET_FUNC_BV(rotordiameter(turb), rotordiameterb(1&
&                            , turb), theta_c_0, theta_c_0b, x0, x0b, &
&                            yaw(turb), yawb(1, turb), ky_local(turb), &
&                            ky_localb(1, turb), kz_local(turb), &
&                            kz_localb(1, turb), ct_local(turb), &
&                            ct_localb(1, turb), sigmay, sigmayb, sigmaz&
&                            , sigmazb, wake_offset, wake_offsetb, &
&                            nbdirs)
          CALL POPREAL8(sigmaz)
          CALL SIGMAZ_FUNC_BV(kz_local(turb), kz_localb(1, turb), &
&                       deltax0, deltax0b, rotordiameter(turb), &
&                       rotordiameterb(1, turb), sigmaz, sigmazb, nbdirs&
&                      )
          CALL POPREAL8(sigmay)
          CALL SIGMAY_FUNC_BV(ky_local(turb), ky_localb(1, turb), &
&                       deltax0, deltax0b, rotordiameter(turb), &
&                       rotordiameterb(1, turb), yaw(turb), yawb(1, turb&
&                       ), sigmay, sigmayb, nbdirs)
          CALL POPREAL8(theta_c_0)
          CALL THETA_C_0_FUNC_BV(yaw(turb), yawb(1, turb), ct_local(turb&
&                          ), ct_localb(1, turb), theta_c_0, theta_c_0b&
&                          , nbdirs)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            DO nd=1,nbdirs
              k_starb(nd) = ky_localb(nd, turb) + kz_localb(nd, turb)
              kz_localb(nd, turb) = 0.0_8
              ky_localb(nd, turb) = 0.0_8
            END DO
            CALL POPREAL8(kz_local(turb))
            CALL POPREAL8(ky_local(turb))
            CALL K_STAR_FUNC_BV(titurbs(turb), titurbsb(1, turb), k_star&
&                         , k_starb, nbdirs)
          END IF
          DO nd=1,nbdirs
            xb(nd) = xb(nd) + deltax0b(nd)
            x0b(nd) = x0b(nd) - deltax0b(nd)
          END DO
          CALL POPREAL8(deltax0)
          CALL POPREAL8(x0)
          CALL X0_FUNC_BV(rotordiameter(turb), rotordiameterb(1, turb), &
&                   yaw(turb), yawb(1, turb), ct_local(turb), ct_localb(&
&                   1, turb), alpha, titurbs(turb), titurbsb(1, turb), &
&                   beta, x0, x0b, nbdirs)
        END IF
        CALL POPREAL8(x)
        DO nd=1,nbdirs
          turbinexwb(nd, turbi) = turbinexwb(nd, turbi) + xb(nd)
          turbinexwb(nd, turb) = turbinexwb(nd, turb) - xb(nd)
          localrotorpointyb(nd) = localrotorpointyb(nd) + SIN(yaw(turbi)&
&           )*xb(nd)
          yawb(nd, turbi) = yawb(nd, turbi) + localrotorpointy*COS(yaw(&
&           turbi))*xb(nd)
        END DO
 100    CALL POPINTEGER4(turb)
      END DO
      DO nd=1,nbdirs
        rotordiameterb(nd, turbi) = rotordiameterb(nd, turbi) + &
&         rotorpointsy(p)*0.5_dp*localrotorpointyb(nd) + rotorpointsz(p)&
&         *0.5_dp*localrotorpointzb(nd)
      END DO
    END DO
    CALL POPINTEGER4(turbi)
  END DO
  DO nd=1,nbdirs
    ctb(nd, :) = 0.0_8
    ctb(nd, :) = ct_localb(nd, :)
    yawdegb(nd, :) = 0.0_8
    yawdegb(nd, :) = -(pi*yawb(nd, :)/180.0_dp)
  END DO
  DO nd=1,nbdirs
    wtvelocityb(nd, :) = 0.0_8
  END DO
END SUBROUTINE PORTEAGEL_ANALYZE_BV

!  Differentiation of x0_func in reverse (adjoint) mode:
!   gradient     of useful results: ti yaw rotor_diameter x0 ct
!   with respect to varying inputs: ti yaw rotor_diameter ct
! calculates the onset of far-wake conditions
SUBROUTINE X0_FUNC_BV(rotor_diameter, rotor_diameterb, yaw, yawb, ct, &
& ctb, alpha, ti, tib, beta, x0, x0b, nbdirs)
  !USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: rotor_diameter, yaw, ct, alpha, ti, beta
  REAL(dp), DIMENSION(nbdirs) :: rotor_diameterb, yawb, ctb, tib
! out
  REAL(dp) :: x0
  REAL(dp), DIMENSION(nbdirs) :: x0b
  INTRINSIC COS, SQRT
! determine the onset location of far wake
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp) :: temp1
  REAL(dp) :: temp2
  REAL(dp) :: temp3
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  INTEGER :: nbdirs
  temp3 = SQRT(-ct + 1.0_dp)
  temp2 = SQRT(2.0_dp)
  temp1 = temp2*(alpha*ti+beta*(-temp3+1.0_dp))
  temp0 = SQRT(-ct + 1.0_dp)
  temp = COS(yaw)
  DO nd=1,nbdirs
    tempb(nd) = x0b(nd)/temp1
    tempb0(nd) = -(rotor_diameter*temp*(temp0+1.0_dp)*temp2*tempb(nd)/&
&     temp1)
    rotor_diameterb(nd) = rotor_diameterb(nd) + (temp0+1.0_dp)*temp*&
&     tempb(nd)
    yawb(nd) = yawb(nd) - rotor_diameter*(temp0+1.0_dp)*SIN(yaw)*tempb(&
&     nd)
    IF (.NOT.1.0_dp - ct .EQ. 0.0) ctb(nd) = ctb(nd) + beta*tempb0(nd)/(&
&       2.0*temp3) - rotor_diameter*temp*tempb(nd)/(2.0*temp0)
    tib(nd) = tib(nd) + alpha*tempb0(nd)
  END DO
END SUBROUTINE X0_FUNC_BV

!  Differentiation of theta_c_0_func in reverse (adjoint) mode:
!   gradient     of useful results: theta_c_0 yaw ct
!   with respect to varying inputs: yaw ct
! calculates the wake angle at the onset of far wake conditions
SUBROUTINE THETA_C_0_FUNC_BV(yaw, yawb, ct, ctb, theta_c_0, theta_c_0b, &
& nbdirs)
  !USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: yaw, ct
  REAL(dp), DIMENSION(nbdirs) :: yawb, ctb
! out
  REAL(dp) :: theta_c_0
  REAL(dp), DIMENSION(nbdirs) :: theta_c_0b
  INTRINSIC COS, SQRT
! determine the initial wake angle at the onset of far wake
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp) :: temp1
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  INTEGER :: nbdirs
  temp1 = COS(yaw)
  temp0 = COS(yaw)
  temp = SQRT(-(ct*temp0) + 1.0_dp)
  DO nd=1,nbdirs
    IF (1.0_dp - ct*temp0 .EQ. 0.0) THEN
      tempb(nd) = 0.0
    ELSE
      tempb(nd) = -(yaw*0.3_dp*theta_c_0b(nd)/(temp1*2.0*temp))
    END IF
    tempb0(nd) = (1.0_dp-temp)*0.3_dp*theta_c_0b(nd)/temp1
    ctb(nd) = ctb(nd) - temp0*tempb(nd)
    yawb(nd) = yawb(nd) + (yaw*SIN(yaw)/temp1+1.0_8)*tempb0(nd) + ct*SIN&
&     (yaw)*tempb(nd)
  END DO
END SUBROUTINE THETA_C_0_FUNC_BV

!  Differentiation of sigmay_func in reverse (adjoint) mode:
!   gradient     of useful results: yaw sigmay ky rotor_diameter
!                deltax0
!   with respect to varying inputs: yaw ky rotor_diameter deltax0
! calculates the horizontal spread of the wake at a given distance from the onset of far 
! wake condition
SUBROUTINE SIGMAY_FUNC_BV(ky, kyb, deltax0, deltax0b, rotor_diameter, &
& rotor_diameterb, yaw, yawb, sigmay, sigmayb, nbdirs)
  !USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: ky, deltax0, rotor_diameter, yaw
  REAL(dp), DIMENSION(nbdirs) :: kyb, deltax0b, rotor_diameterb, yawb
! out
  REAL(dp) :: sigmay
  REAL(dp), DIMENSION(nbdirs) :: sigmayb
  INTRINSIC COS, SQRT
! horizontal spread
  REAL(dp) :: temp
  REAL(dp) :: temp0
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  INTEGER :: nbdirs
  temp0 = SQRT(8.0_dp)
  temp = ky*deltax0/rotor_diameter
  DO nd=1,nbdirs
    tempb(nd) = sigmayb(nd)
    rotor_diameterb(nd) = rotor_diameterb(nd) + (temp+COS(yaw)/temp0)*&
&     sigmayb(nd) - temp*tempb(nd)
    kyb(nd) = kyb(nd) + deltax0*tempb(nd)
    deltax0b(nd) = deltax0b(nd) + ky*tempb(nd)
    yawb(nd) = yawb(nd) - rotor_diameter*SIN(yaw)*sigmayb(nd)/temp0
  END DO
END SUBROUTINE SIGMAY_FUNC_BV

!  Differentiation of sigmaz_func in reverse (adjoint) mode:
!   gradient     of useful results: sigmaz kz rotor_diameter
!   with respect to varying inputs: kz rotor_diameter deltax0
! calculates the vertical spread of the wake at a given distance from the onset of far 
! wake condition
SUBROUTINE SIGMAZ_FUNC_BV(kz, kzb, deltax0, deltax0b, rotor_diameter, &
& rotor_diameterb, sigmaz, sigmazb, nbdirs)
  !USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: kz, deltax0, rotor_diameter
  REAL(dp), DIMENSION(nbdirs) :: kzb, deltax0b, rotor_diameterb
! out
  REAL(dp) :: sigmaz
  REAL(dp), DIMENSION(nbdirs) :: sigmazb
! load necessary intrinsic functions
  INTRINSIC SQRT
! vertical spread
  REAL(dp) :: temp
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  INTEGER :: nbdirs
  temp = kz*deltax0/rotor_diameter
  DO nd=1,nbdirs
    tempb(nd) = sigmazb(nd)
    rotor_diameterb(nd) = rotor_diameterb(nd) + (1.0/SQRT(8.0_dp)+temp)*&
&     sigmazb(nd) - temp*tempb(nd)
    kzb(nd) = kzb(nd) + deltax0*tempb(nd)
    deltax0b(nd) = kz*tempb(nd)
  END DO
END SUBROUTINE SIGMAZ_FUNC_BV

!  Differentiation of wake_offset_func in reverse (adjoint) mode:
!   gradient     of useful results: yaw sigmay sigmaz ky kz rotor_diameter
!                x0 wake_offset ct
!   with respect to varying inputs: theta_c_0 yaw sigmay sigmaz
!                ky kz rotor_diameter x0 ct
! calculates the horizontal distance from the wake center to the hub of the turbine making
! the wake
SUBROUTINE WAKE_OFFSET_FUNC_BV(rotor_diameter, rotor_diameterb, &
& theta_c_0, theta_c_0b, x0, x0b, yaw, yawb, ky, kyb, kz, kzb, ct, ctb, &
& sigmay, sigmayb, sigmaz, sigmazb, wake_offset, wake_offsetb, nbdirs)
  !USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: rotor_diameter, theta_c_0, x0, yaw, ky, kz, ct&
& , sigmay
  REAL(dp), DIMENSION(nbdirs) :: rotor_diameterb, theta_c_0b, x0b, &
& yawb, kyb, kzb, ctb, sigmayb
  REAL(dp), INTENT(IN) :: sigmaz
  REAL(dp), DIMENSION(nbdirs) :: sigmazb
! out
  REAL(dp) :: wake_offset
  REAL(dp), DIMENSION(nbdirs) :: wake_offsetb
  INTRINSIC COS, SQRT, LOG
! horizontal cross-wind wake displacement from hub
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp) :: temp1
  REAL(dp) :: temp2
  REAL(dp) :: temp3
  REAL(dp) :: temp4
  REAL(dp) :: temp5
  REAL(dp) :: temp6
  REAL(dp) :: temp7
  REAL(dp) :: temp8
  REAL(dp) :: temp9
  REAL(dp) :: temp10
  REAL(dp) :: temp11
  REAL(dp) :: temp12
  REAL(dp) :: temp13
  REAL(dp) :: temp14
  REAL(dp) :: temp15
  REAL(dp) :: temp16
  REAL(dp) :: temp17
  REAL(dp) :: temp18
  REAL(dp) :: temp19
  REAL(dp) :: temp20
  REAL(dp) :: temp21
  REAL(dp) :: temp22
  REAL(dp) :: temp23
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  REAL(dp), DIMENSION(nbdirs) :: tempb2
  REAL(dp), DIMENSION(nbdirs) :: tempb3
  REAL(dp), DIMENSION(nbdirs) :: tempb4
  REAL(dp), DIMENSION(nbdirs) :: tempb5
  REAL(dp), DIMENSION(nbdirs) :: tempb6
  REAL(dp), DIMENSION(nbdirs) :: tempb7
  REAL(dp), DIMENSION(nbdirs) :: tempb8
  REAL(dp), DIMENSION(nbdirs) :: tempb9
  INTEGER :: nbdirs
  temp23 = SQRT(ct)
  temp22 = COS(yaw)
  temp7 = temp22*rotor_diameter**2
  temp6 = sigmay*sigmaz/temp7
  temp21 = SQRT(8.0_dp*temp6)
  temp20 = SQRT(ct)
  temp5 = (-temp20+1.6_dp)*(1.6_dp*temp21+temp23)
  temp19 = SQRT(ct)
  temp18 = COS(yaw)
  temp4 = temp18*rotor_diameter**2
  temp3 = sigmay*sigmaz/temp4
  temp17 = SQRT(8.0_dp*temp3)
  temp16 = 1.6_dp*temp17 - temp19
  temp15 = SQRT(ct)
  temp2 = (temp15+1.6_dp)*temp16/temp5
  temp14 = LOG(temp2)
  temp13 = SQRT(-ct + 1.0_dp)
  temp12 = 1.3_dp*temp13 - ct + 2.9_dp
  temp11 = theta_c_0/14.7_dp
  temp1 = ky*kz*ct
  temp10 = COS(yaw)
  temp0 = temp10/temp1
  temp9 = SQRT(temp0)
  temp8 = temp9*temp11*temp12
  temp = theta_c_0*x0/rotor_diameter
  DO nd=1,nbdirs
    tempb(nd) = rotor_diameter*wake_offsetb(nd)
    tempb0(nd) = tempb(nd)/rotor_diameter
    IF (temp0 .EQ. 0.0) THEN
      tempb1(nd) = 0.0
    ELSE
      tempb1(nd) = temp11*temp12*temp14*tempb(nd)/(2.0*temp9*temp1)
    END IF
    tempb2(nd) = -(temp0*tempb1(nd))
    tempb3(nd) = temp14*temp9*tempb(nd)
    tempb4(nd) = temp8*tempb(nd)/(temp2*temp5)
    IF (8.0_dp*temp3 .EQ. 0.0) THEN
      tempb5(nd) = 0.0
    ELSE
      tempb5(nd) = 8.0_dp*1.6_dp*(temp15+1.6_dp)*tempb4(nd)/(2.0*temp17*&
&       temp4)
    END IF
    tempb6(nd) = -(temp3*tempb5(nd))
    tempb7(nd) = -(temp2*tempb4(nd))
    IF (8.0_dp*temp6 .EQ. 0.0) THEN
      tempb8(nd) = 0.0
    ELSE
      tempb8(nd) = 8.0_dp*1.6_dp*(1.6_dp-temp20)*tempb7(nd)/(2.0*temp21*&
&       temp7)
    END IF
    tempb9(nd) = -(temp6*tempb8(nd))
    rotor_diameterb(nd) = rotor_diameterb(nd) + temp22*2*rotor_diameter*&
&     tempb9(nd) + temp18*2*rotor_diameter*tempb6(nd) - temp*tempb0(nd) &
&     + (temp+temp8*temp14)*wake_offsetb(nd)
    theta_c_0b(nd) = temp12*tempb3(nd)/14.7_dp + x0*tempb0(nd)
    x0b(nd) = x0b(nd) + theta_c_0*tempb0(nd)
    yawb(nd) = yawb(nd) - rotor_diameter**2*SIN(yaw)*tempb9(nd) - &
&     rotor_diameter**2*SIN(yaw)*tempb6(nd) - SIN(yaw)*tempb1(nd)
    kyb(nd) = kyb(nd) + ct*kz*tempb2(nd)
    kzb(nd) = kzb(nd) + ct*ky*tempb2(nd)
    IF (1.0_dp - ct .EQ. 0.0) THEN
      ctb(nd) = ctb(nd) + ky*kz*tempb2(nd) - temp11*tempb3(nd)
    ELSE
      ctb(nd) = ctb(nd) + ((1.6_dp-temp20)/(2.0*temp23)-(1.6_dp*temp21+&
&       temp23)/(2.0*temp20))*tempb7(nd) + (temp16/(2.0*temp15)-(temp15+&
&       1.6_dp)/(2.0*temp19))*tempb4(nd) + (-temp11-1.3_dp*temp11/(2.0*&
&       temp13))*tempb3(nd) + ky*kz*tempb2(nd)
    END IF
    sigmayb(nd) = sigmayb(nd) + sigmaz*tempb8(nd) + sigmaz*tempb5(nd)
    sigmazb(nd) = sigmazb(nd) + sigmay*tempb8(nd) + sigmay*tempb5(nd)
  END DO
END SUBROUTINE WAKE_OFFSET_FUNC_BV

!  Differentiation of deltav_func in reverse (adjoint) mode:
!   gradient     of useful results: k yaw rotor_diameter_ust deltav
!                deltax deltay ct
!   with respect to varying inputs: k yaw rotor_diameter_ust sigmay
!                sigmaz deltax deltay deltaz ct
! calculates the velocity difference between hub velocity and free stream for a given wake
! for use in the far wake region
SUBROUTINE DELTAV_FUNC_BV(deltay, deltayb, deltaz, deltazb, ct, ctb, yaw&
& , yawb, sigmay, sigmayb, sigmaz, sigmazb, rotor_diameter_ust, &
& rotor_diameter_ustb, version, k, kb, deltax, deltaxb, opt_exp_fac, &
& deltav, deltavb, nbdirs)
  !USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
!print *, "rotor_diameter in deltav exit", rotor_diameter_ust
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: deltay, deltaz, ct, yaw, sigmay
  REAL(dp), DIMENSION(nbdirs) :: deltayb, deltazb, ctb, yawb, sigmayb
  REAL(dp), INTENT(IN) :: sigmaz, rotor_diameter_ust, opt_exp_fac
  REAL(dp), DIMENSION(nbdirs) :: sigmazb, rotor_diameter_ustb
! only for 2014 version
  REAL(dp), INTENT(IN) :: k, deltax
  REAL(dp), DIMENSION(nbdirs) :: kb, deltaxb
  INTEGER, INTENT(IN) :: version
! local
! only for 2014 version
  REAL(dp) :: beta_2014, epsilon_2014
  REAL(dp), DIMENSION(nbdirs) :: beta_2014b, epsilon_2014b
! out
  REAL(dp) :: deltav
  REAL(dp), DIMENSION(nbdirs) :: deltavb
! load intrinsic functions
  INTRINSIC COS, SQRT, EXP
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp) :: temp1
  REAL(dp) :: temp2
  REAL(dp) :: temp3
  REAL(dp) :: temp4
  REAL(dp) :: temp5
  REAL(dp) :: temp6
  REAL(dp) :: temp7
  REAL(dp) :: temp8
  REAL(dp) :: temp9
  REAL(dp) :: temp10
  REAL(dp) :: temp11
  REAL(dp) :: temp12
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  REAL(dp), DIMENSION(nbdirs) :: tempb2
  REAL(dp), DIMENSION(nbdirs) :: tempb3
  REAL(dp), DIMENSION(nbdirs) :: tempb4
  REAL(dp), DIMENSION(nbdirs) :: tempb5
  REAL(dp), DIMENSION(nbdirs) :: tempb6
  REAL(dp), DIMENSION(nbdirs) :: tempb7
  REAL(dp) :: temp13
  REAL(dp) :: temp14
  REAL(dp) :: temp15
  REAL(dp) :: temp16
  REAL(dp) :: temp17
  REAL(dp) :: temp18
  REAL(dp) :: temp19
  REAL(dp) :: temp20
  REAL(dp) :: temp21
  REAL(dp) :: temp22
  REAL(dp) :: temp23
  REAL(dp), DIMENSION(nbdirs) :: tempb8
  REAL(dp), DIMENSION(nbdirs) :: tempb9
  REAL(dp), DIMENSION(nbdirs) :: tempb10
  REAL(dp), DIMENSION(nbdirs) :: tempb11
  REAL(dp), DIMENSION(nbdirs) :: tempb12
  INTEGER :: nbdirs
!print *, "rotor_diameter in deltav entry", rotor_diameter_ust
!     print *, 'wake model version in deltav: ', version
  IF (version .EQ. 2014) THEN
!print *, "in 2014 version"
    beta_2014 = 0.5_dp*(1.0_dp+SQRT(1.0_dp-ct))/SQRT(1.0_dp-ct)
    epsilon_2014 = 0.2_dp*SQRT(beta_2014)
! print *, "beta = ", beta_2014, "epsilon = ", epsilon_2014
! print *, "k, deltax: ", k, deltax
! print *, "term: ", Ct                                                   &
!                            / (8.0_dp * (k*deltax/rotor_diameter_ust+epsilon_2014)**2)
! print *, "deltav 2014 = ", deltav
    temp6 = k*deltax/rotor_diameter_ust
    temp12 = 2.0_dp*(temp6+epsilon_2014)**2
    temp11 = opt_exp_fac*rotor_diameter_ust
    temp5 = deltay/temp11
    temp10 = opt_exp_fac*rotor_diameter_ust
    temp4 = deltaz/temp10
    temp9 = temp4**2 + temp5**2
    temp3 = temp9/temp12
    temp2 = k*deltax/rotor_diameter_ust
    temp8 = 8.0_dp*(temp2+epsilon_2014)**2
    temp1 = ct/temp8
    temp7 = SQRT(-temp1 + 1.0_dp)
    temp0 = SQRT(-ct + 1.0_dp)
    temp = SQRT(-ct + 1.0_dp)
    DO nd=1,nbdirs
      IF (1.0_dp - temp1 .EQ. 0.0) THEN
        tempb(nd) = 0.0
      ELSE
        tempb(nd) = EXP(-temp3)*deltavb(nd)/(2.0*temp7*temp8)
      END IF
      tempb0(nd) = -(8.0_dp*temp1*2*(temp2+epsilon_2014)*tempb(nd))
      tempb1(nd) = tempb0(nd)/rotor_diameter_ust
      tempb2(nd) = -(EXP(-temp3)*(1.0_dp-temp7)*deltavb(nd)/temp12)
      tempb3(nd) = 2*temp4*tempb2(nd)/temp10
      tempb4(nd) = 2*temp5*tempb2(nd)/temp11
      tempb5(nd) = -(2.0_dp*temp3*2*(temp6+epsilon_2014)*tempb2(nd))
      tempb6(nd) = tempb5(nd)/rotor_diameter_ust
      ctb(nd) = ctb(nd) + tempb(nd)
      kb(nd) = kb(nd) + deltax*tempb6(nd) + deltax*tempb1(nd)
      deltaxb(nd) = deltaxb(nd) + k*tempb6(nd) + k*tempb1(nd)
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) - temp6*tempb6(&
&       nd) - temp5*opt_exp_fac*tempb4(nd) - temp4*opt_exp_fac*tempb3(nd&
&       ) - temp2*tempb1(nd)
      epsilon_2014b(nd) = tempb5(nd) + tempb0(nd)
      deltazb(nd) = tempb3(nd)
      deltayb(nd) = deltayb(nd) + tempb4(nd)
      IF (beta_2014 .EQ. 0.0) THEN
        beta_2014b(nd) = 0.0
      ELSE
        beta_2014b(nd) = 0.2_dp*epsilon_2014b(nd)/(2.0*SQRT(beta_2014))
      END IF
      tempb7(nd) = 0.5_dp*beta_2014b(nd)/temp0
      IF (.NOT.1.0_dp - ct .EQ. 0.0) ctb(nd) = ctb(nd) + ((temp+1.0_dp)/&
&         (2.0*temp0**2)-1.0/(2.0*temp))*tempb7(nd)
    END DO
    DO nd=1,nbdirs
      sigmayb(nd) = 0.0_8
      sigmazb(nd) = 0.0_8
    END DO
  ELSE IF (version .EQ. 2016) THEN
    temp23 = opt_exp_fac**2*sigmaz**2
    temp16 = deltaz**2/temp23
    temp22 = EXP(-(0.5_dp*temp16))
    temp21 = opt_exp_fac**2*sigmay**2
    temp15 = deltay**2/temp21
    temp20 = EXP(-(0.5_dp*temp15))
    temp14 = 8.0_dp*sigmay*sigmaz
    temp19 = ct*rotor_diameter_ust**2
    temp13 = temp19/temp14
    temp18 = COS(yaw)
    temp17 = SQRT(-(temp18*temp13) + 1.0_dp)
    DO nd=1,nbdirs
      IF (1.0_dp - temp18*temp13 .EQ. 0.0) THEN
        tempb8(nd) = 0.0
      ELSE
        tempb8(nd) = -(temp20*temp22*deltavb(nd)/(2.0*temp17))
      END IF
      tempb9(nd) = -(temp18*tempb8(nd)/temp14)
      tempb10(nd) = -(temp13*tempb9(nd))
      tempb11(nd) = -(0.5_dp*EXP(-(0.5_dp*temp15))*temp22*(1.0_dp-temp17&
&       )*deltavb(nd)/temp21)
      tempb12(nd) = -(0.5_dp*EXP(-(0.5_dp*temp16))*temp20*(1.0_dp-temp17&
&       )*deltavb(nd)/temp23)
      yawb(nd) = yawb(nd) + temp13*SIN(yaw)*tempb8(nd)
      ctb(nd) = ctb(nd) + rotor_diameter_ust**2*tempb9(nd)
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + ct*2*&
&       rotor_diameter_ust*tempb9(nd)
      sigmayb(nd) = sigmaz*8.0_dp*tempb10(nd) - opt_exp_fac**2*temp15*2*&
&       sigmay*tempb11(nd)
      sigmazb(nd) = 8.0_dp*sigmay*tempb10(nd) - opt_exp_fac**2*temp16*2*&
&       sigmaz*tempb12(nd)
      deltayb(nd) = deltayb(nd) + 2*deltay*tempb11(nd)
      deltazb(nd) = 2*deltaz*tempb12(nd)
    END DO
  ELSE
    STOP
  END IF
END SUBROUTINE DELTAV_FUNC_BV

!  Differentiation of deltav_near_wake_lin_func in reverse (adjoint) mode:
!   gradient     of useful results: k yaw x rotor_diameter_ust
!                deltav deltay ct
!   with respect to varying inputs: k yaw discontinuity_point x
!                rotor_diameter_ust sigmay sigmaz deltax0_dp deltay
!                deltaz sigmay0 ct sigmaz0
! calculates the velocity difference between hub velocity and free stream for a given wake
! for use in the near wake region only
SUBROUTINE DELTAV_NEAR_WAKE_LIN_FUNC_BV(deltay, deltayb, deltaz, deltazb&
& , ct, ctb, yaw, yawb, sigmay, sigmayb, sigmaz, sigmazb, &
& rotor_diameter_ust, rotor_diameter_ustb, x, xb, discontinuity_point, &
& discontinuity_pointb, sigmay0, sigmay0b, sigmaz0, sigmaz0b, version, k&
& , kb, deltax0_dp, deltax0_dpb, opt_exp_fac, deltav, deltavb, nbdirs)
  !USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: deltay, deltaz, ct, yaw, sigmay
  REAL(dp), DIMENSION(nbdirs) :: deltayb, deltazb, ctb, yawb, sigmayb
  REAL(dp), INTENT(IN) :: sigmaz, rotor_diameter_ust, opt_exp_fac
  REAL(dp), DIMENSION(nbdirs) :: sigmazb, rotor_diameter_ustb
  REAL(dp), INTENT(IN) :: x, discontinuity_point, sigmay0, sigmaz0
  REAL(dp), DIMENSION(nbdirs) :: xb, discontinuity_pointb, sigmay0b, &
& sigmaz0b
! only for 2014 version
  REAL(dp), INTENT(IN) :: k, deltax0_dp
  REAL(dp), DIMENSION(nbdirs) :: kb, deltax0_dpb
  INTEGER, INTENT(IN) :: version
! local
  REAL(dp) :: deltav0m, deltavr
  REAL(dp), DIMENSION(nbdirs) :: deltav0mb, deltavrb
! only for 2014 version
  REAL(dp) :: beta_2014, epsilon_2014
  REAL(dp), DIMENSION(nbdirs) :: beta_2014b, epsilon_2014b
! out
  REAL(dp) :: deltav
  REAL(dp), DIMENSION(nbdirs) :: deltavb
! load intrinsic functions
  INTRINSIC COS, SQRT, EXP
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp) :: temp1
  REAL(dp) :: temp2
  REAL(dp) :: temp3
  REAL(dp) :: temp4
  REAL(dp) :: temp5
  REAL(dp) :: temp6
  REAL(dp) :: temp7
  REAL(dp) :: temp8
  REAL(dp) :: temp9
  REAL(dp) :: temp10
  REAL(dp) :: temp11
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  REAL(dp), DIMENSION(nbdirs) :: tempb2
  REAL(dp), DIMENSION(nbdirs) :: tempb3
  REAL(dp), DIMENSION(nbdirs) :: tempb4
  REAL(dp), DIMENSION(nbdirs) :: tempb5
  REAL(dp), DIMENSION(nbdirs) :: tempb6
  REAL(dp), DIMENSION(nbdirs) :: tempb7
  REAL(dp), DIMENSION(nbdirs) :: tempb8
  REAL(dp), DIMENSION(nbdirs) :: tempb9
  REAL(dp) :: temp12
  REAL(dp) :: temp13
  REAL(dp) :: temp14
  REAL(dp) :: temp15
  REAL(dp) :: temp16
  REAL(dp) :: temp17
  REAL(dp) :: temp18
  REAL(dp) :: temp19
  REAL(dp) :: temp20
  REAL(dp) :: temp21
  REAL(dp) :: temp22
  REAL(dp), DIMENSION(nbdirs) :: tempb10
  REAL(dp), DIMENSION(nbdirs) :: tempb11
  REAL(dp), DIMENSION(nbdirs) :: tempb12
  REAL(dp), DIMENSION(nbdirs) :: tempb13
  REAL(dp), DIMENSION(nbdirs) :: tempb14
  REAL(dp), DIMENSION(nbdirs) :: tempb15
  REAL(dp), DIMENSION(nbdirs) :: tempb16
  REAL(dp), DIMENSION(nbdirs) :: tempb17
  INTEGER :: nbdirs
!  print *, 'wake model version in deltav near wake: ', version
!     print *, "inputs: ", deltay, deltaz, Ct, yaw,  &
!                                  & sigmay, sigmaz, rotor_diameter_ust, x, &
!                                  & discontinuity_point, sigmay0, sigmaz0, version, k, &
!                                  & deltax0_dp, opt_exp_fac
  IF (version .EQ. 2014) THEN
    IF (yaw .GT. 0.0_dp) THEN
      STOP
    ELSE
      beta_2014 = 0.5_dp*(1.0_dp+SQRT(1.0_dp-ct))/SQRT(1.0_dp-ct)
      epsilon_2014 = 0.2_dp*SQRT(beta_2014)
! magnitude term of gaussian at x0
      deltav0m = 1.0_dp - SQRT(1.0_dp - ct/(8.0_dp*(k*deltax0_dp/&
&       rotor_diameter_ust+epsilon_2014)**2))
! initialize the gaussian magnitude term at the rotor for the linear interpolation
      deltavr = deltav0m
! linearized gaussian magnitude term for near wake
      temp7 = k*deltax0_dp/rotor_diameter_ust
      temp11 = 2.0_dp*(temp7+epsilon_2014)**2
      temp10 = opt_exp_fac*rotor_diameter_ust
      temp6 = deltay/temp10
      temp9 = opt_exp_fac*rotor_diameter_ust
      temp5 = deltaz/temp9
      temp8 = temp5**2 + temp6**2
      temp4 = temp8/temp11
      temp3 = x/discontinuity_point
      temp1 = k*deltax0_dp/rotor_diameter_ust
      temp2 = 8.0_dp*(temp1+epsilon_2014)**2
      temp0 = SQRT(-ct + 1.0_dp)
      temp = SQRT(-ct + 1.0_dp)
      DO nd=1,nbdirs
        tempb(nd) = EXP(-temp4)*deltavb(nd)
        tempb0(nd) = (deltav0m-deltavr)*tempb(nd)/discontinuity_point
        tempb1(nd) = -(EXP(-temp4)*((deltav0m-deltavr)*temp3+deltavr)*&
&         deltavb(nd)/temp11)
        tempb2(nd) = 2*temp5*tempb1(nd)/temp9
        tempb3(nd) = 2*temp6*tempb1(nd)/temp10
        tempb4(nd) = -(2.0_dp*temp4*2*(temp7+epsilon_2014)*tempb1(nd))
        tempb5(nd) = tempb4(nd)/rotor_diameter_ust
        deltavrb(nd) = (1.0_8-temp3)*tempb(nd)
        deltav0mb(nd) = deltavrb(nd) + temp3*tempb(nd)
        xb(nd) = xb(nd) + tempb0(nd)
        discontinuity_pointb(nd) = -(temp3*tempb0(nd))
        deltazb(nd) = tempb2(nd)
        deltayb(nd) = deltayb(nd) + tempb3(nd)
        IF (1.0_dp - ct/temp2 .EQ. 0.0) THEN
          tempb8(nd) = 0.0
        ELSE
          tempb8(nd) = deltav0mb(nd)/(2.0*SQRT(1.0_dp-ct/temp2)*temp2)
        END IF
        tempb7(nd) = -(8.0_dp*ct*2*(temp1+epsilon_2014)*tempb8(nd)/temp2&
&         )
        epsilon_2014b(nd) = tempb7(nd) + tempb4(nd)
        tempb6(nd) = tempb7(nd)/rotor_diameter_ust
        rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) - temp1*tempb6&
&         (nd) - temp7*tempb5(nd) - temp6*opt_exp_fac*tempb3(nd) - temp5&
&         *opt_exp_fac*tempb2(nd)
        kb(nd) = kb(nd) + deltax0_dp*tempb6(nd) + deltax0_dp*tempb5(nd)
        deltax0_dpb(nd) = k*tempb6(nd) + k*tempb5(nd)
        ctb(nd) = ctb(nd) + tempb8(nd)
        IF (beta_2014 .EQ. 0.0) THEN
          beta_2014b(nd) = 0.0
        ELSE
          beta_2014b(nd) = 0.2_dp*epsilon_2014b(nd)/(2.0*SQRT(beta_2014)&
&           )
        END IF
        tempb9(nd) = 0.5_dp*beta_2014b(nd)/temp0
        IF (.NOT.1.0_dp - ct .EQ. 0.0) ctb(nd) = ctb(nd) + ((temp+1.0_dp&
&           )/(2.0*temp0**2)-1.0/(2.0*temp))*tempb9(nd)
      END DO
      DO nd=1,nbdirs
        sigmayb(nd) = 0.0_8
        sigmazb(nd) = 0.0_8
        sigmay0b(nd) = 0.0_8
        sigmaz0b(nd) = 0.0_8
      END DO
    END IF
  ELSE IF (version .EQ. 2016) THEN
! magnitude term of gaussian at x0
    deltav0m = 1.0_dp - SQRT(1.0_dp - ct*COS(yaw)/(8.0_dp*sigmay0*&
&     sigmaz0/rotor_diameter_ust**2))
! initialize the gaussian magnitude term at the rotor for the linear interpolation
    deltavr = deltav0m
! linearized gaussian magnitude term for near wake
    temp22 = opt_exp_fac**2*sigmaz**2
    temp19 = deltaz**2/temp22
    temp21 = opt_exp_fac**2*sigmay**2
    temp18 = deltay**2/temp21
    temp20 = EXP(-(0.5_dp*temp18))
    temp17 = x/discontinuity_point
    temp16 = (deltav0m-deltavr)*temp17 + deltavr
    temp13 = 8.0_dp*sigmay0*sigmaz0
    temp15 = ct*rotor_diameter_ust**2
    temp12 = temp15/temp13
    temp14 = COS(yaw)
    DO nd=1,nbdirs
      tempb10(nd) = EXP(-(0.5_dp*temp19))*deltavb(nd)
      tempb11(nd) = temp20*tempb10(nd)
      tempb12(nd) = (deltav0m-deltavr)*tempb11(nd)/discontinuity_point
      tempb13(nd) = -(0.5_dp*EXP(-(0.5_dp*temp18))*temp16*tempb10(nd)/&
&       temp21)
      tempb14(nd) = -(0.5_dp*EXP(-(0.5_dp*temp19))*temp16*temp20*deltavb&
&       (nd)/temp22)
      deltavrb(nd) = (1.0_8-temp17)*tempb11(nd)
      deltav0mb(nd) = deltavrb(nd) + temp17*tempb11(nd)
      xb(nd) = xb(nd) + tempb12(nd)
      discontinuity_pointb(nd) = -(temp17*tempb12(nd))
      deltayb(nd) = deltayb(nd) + 2*deltay*tempb13(nd)
      sigmayb(nd) = -(opt_exp_fac**2*temp18*2*sigmay*tempb13(nd))
      deltazb(nd) = 2*deltaz*tempb14(nd)
      sigmazb(nd) = -(opt_exp_fac**2*temp19*2*sigmaz*tempb14(nd))
      IF (1.0_dp - temp14*temp12 .EQ. 0.0) THEN
        tempb15(nd) = 0.0
      ELSE
        tempb15(nd) = -(deltav0mb(nd)/(2.0*SQRT(1.0_dp-temp14*temp12)))
      END IF
      tempb16(nd) = -(temp14*tempb15(nd)/temp13)
      tempb17(nd) = -(temp12*tempb16(nd))
      yawb(nd) = yawb(nd) + temp12*SIN(yaw)*tempb15(nd)
      ctb(nd) = ctb(nd) + rotor_diameter_ust**2*tempb16(nd)
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + ct*2*&
&       rotor_diameter_ust*tempb16(nd)
      sigmay0b(nd) = sigmaz0*8.0_dp*tempb17(nd)
      sigmaz0b(nd) = 8.0_dp*sigmay0*tempb17(nd)
    END DO
    DO nd=1,nbdirs
      deltax0_dpb(nd) = 0.0_8
    END DO
  ELSE
    STOP
  END IF
END SUBROUTINE DELTAV_NEAR_WAKE_LIN_FUNC_BV

!  Differentiation of wake_combination_func in reverse (adjoint) mode:
!   gradient     of useful results: turb_inflow deficit_sum
!   with respect to varying inputs: turb_inflow deficit_sum deltav
! combines wakes using various methods
SUBROUTINE WAKE_COMBINATION_FUNC_BV(wind_speed, turb_inflow, &
& turb_inflowb, deltav, deltavb, wake_combination_method, deficit_sum, &
& deficit_sumb, nbdirs)
  !USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: wind_speed, turb_inflow, deltav
  REAL(dp), DIMENSION(nbdirs) :: turb_inflowb, deltavb
  INTEGER, INTENT(IN) :: wake_combination_method
! out    
  REAL(dp), INTENT(INOUT) :: deficit_sum
  REAL(dp), DIMENSION(nbdirs), INTENT(INOUT) :: deficit_sumb
! intrinsic functions
  INTRINSIC SQRT
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  INTEGER :: nbdirs
! freestream linear superposition (Lissaman 1979)
  IF (wake_combination_method .EQ. 0) THEN
    DO nd=1,nbdirs
      deltavb(nd) = wind_speed*deficit_sumb(nd)
    END DO
  ELSE IF (wake_combination_method .EQ. 1) THEN
    DO nd=1,nbdirs
      turb_inflowb(nd) = turb_inflowb(nd) + deltav*deficit_sumb(nd)
      deltavb(nd) = turb_inflow*deficit_sumb(nd)
    END DO
  ELSE IF (wake_combination_method .EQ. 2) THEN
    DO nd=1,nbdirs
      IF (deficit_sum**2 + (wind_speed*deltav)**2 .EQ. 0.0) THEN
        tempb(nd) = 0.0
      ELSE
        tempb(nd) = deficit_sumb(nd)/(2.0*SQRT(deficit_sum**2+(&
&         wind_speed*deltav)**2))
      END IF
      deltavb(nd) = 2*wind_speed**2*deltav*tempb(nd)
      deficit_sumb(nd) = 2*deficit_sum*tempb(nd)
    END DO
  ELSE IF (wake_combination_method .EQ. 3) THEN
    DO nd=1,nbdirs
      IF (deficit_sum**2 + (turb_inflow*deltav)**2 .EQ. 0.0) THEN
        tempb0(nd) = 0.0
      ELSE
        tempb0(nd) = deficit_sumb(nd)/(2.0*SQRT(deficit_sum**2+(&
&         turb_inflow*deltav)**2))
      END IF
      tempb1(nd) = 2*turb_inflow*deltav*tempb0(nd)
      turb_inflowb(nd) = turb_inflowb(nd) + deltav*tempb1(nd)
      deltavb(nd) = turb_inflow*tempb1(nd)
      deficit_sumb(nd) = 2*deficit_sum*tempb0(nd)
    END DO
  ELSE
    STOP
  END IF
END SUBROUTINE WAKE_COMBINATION_FUNC_BV

!  Differentiation of added_ti_func in reverse (adjoint) mode:
!   gradient     of useful results: k_star_ust rotor_diameter_ust
!                wake_height turbine_height ti_dst ct_ust rotor_diameter_dst
!   with respect to varying inputs: k_star_ust x rotor_diameter_ust
!                wake_height turbine_height ti_dst_in ct_ust deltay
!                rotor_diameter_dst ti_ust
! combines wakes using various methods
SUBROUTINE ADDED_TI_FUNC_BV(ti, ct_ust, ct_ustb, x, xb, k_star_ust, &
& k_star_ustb, rotor_diameter_ust, rotor_diameter_ustb, &
& rotor_diameter_dst, rotor_diameter_dstb, deltay, deltayb, wake_height&
& , wake_heightb, turbine_height, turbine_heightb, ti_ust, ti_ustb, &
& ti_calculation_method, ti_area_ratio_in, ti_dst_in, ti_dst_inb, &
& ti_area_ratio, ti_dst, ti_dstb, nbdirs)
  !USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
!print *, "ratio: ", wake_overlap/rotor_area_dst
!print *, "Dr, Dw: ", rotor_diameter_dst, wake_diameter
!print *, "Ar, Aol: ", rotor_area_dst, wake_overlap          
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: ct_ust, x, k_star_ust, rotor_diameter_ust, &
& rotor_diameter_dst
  REAL(dp), DIMENSION(nbdirs) :: ct_ustb, xb, k_star_ustb, &
& rotor_diameter_ustb, rotor_diameter_dstb
  REAL(dp), INTENT(IN) :: deltay, wake_height, turbine_height, ti_ust, &
& ti
  REAL(dp), DIMENSION(nbdirs) :: deltayb, wake_heightb, &
& turbine_heightb, ti_ustb
  REAL(dp), INTENT(IN) :: ti_area_ratio_in, ti_dst_in
  REAL(dp), DIMENSION(nbdirs) :: ti_dst_inb
  INTEGER, INTENT(IN) :: ti_calculation_method
! local
  REAL(dp) :: axial_induction_ust, beta, epsilon, sigma, wake_diameter, &
& wake_overlap
  REAL(dp), DIMENSION(nbdirs) :: axial_induction_ustb, betab, &
& epsilonb, sigmab, wake_diameterb, wake_overlapb
  REAL(dp) :: ti_added, ti_tmp, rotor_area_dst, ti_area_ratio_tmp
  REAL(dp), DIMENSION(nbdirs) :: ti_addedb, ti_tmpb, rotor_area_dstb
  REAL(dp), PARAMETER :: pi=3.141592653589793_dp
! out  
  REAL(dp) :: ti_dst, ti_area_ratio
  REAL(dp), DIMENSION(nbdirs) :: ti_dstb
! intrinsic functions
  INTRINSIC SQRT
  INTEGER :: nd
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp) :: temp1
  REAL(dp) :: temp2
  REAL(dp) :: temp3
  REAL(dp) :: temp4
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  REAL(dp), DIMENSION(nbdirs) :: tempb2
  REAL(dp), DIMENSION(nbdirs) :: tempb3
  REAL(dp) :: temp5
  REAL(dp) :: temp6
  REAL(dp) :: temp7
  REAL(dp) :: temp8
  REAL(dp) :: temp9
  REAL(dp) :: temp10
  REAL(dp), DIMENSION(nbdirs) :: tempb4
  REAL(dp), DIMENSION(nbdirs) :: tempb5
  REAL(dp), DIMENSION(nbdirs) :: tempb6
  REAL(dp), DIMENSION(nbdirs) :: tempb7
  REAL(dp) :: temp11
  REAL(dp) :: temp12
  REAL(dp) :: temp13
  REAL(dp) :: temp14
  REAL(dp) :: temp15
  REAL(dp) :: temp16
  REAL(dp), DIMENSION(nbdirs) :: tempb8
  REAL(dp), DIMENSION(nbdirs) :: tempb9
  REAL(dp), DIMENSION(nbdirs) :: tempb10
  REAL(dp), DIMENSION(nbdirs) :: tempb11
  REAL(dp) :: temp17
  REAL(dp) :: temp18
  REAL(dp) :: temp19
  REAL(dp) :: temp20
  REAL(dp) :: temp21
  REAL(dp) :: temp22
  REAL(dp), DIMENSION(nbdirs) :: tempb12
  REAL(dp), DIMENSION(nbdirs) :: tempb13
  REAL(dp), DIMENSION(nbdirs) :: tempb14
  REAL(dp), DIMENSION(nbdirs) :: tempb15
  REAL(dp) :: temp23
  REAL(dp) :: temp24
  REAL(dp) :: temp25
  REAL(dp) :: temp26
  REAL(dp) :: temp27
  REAL(dp) :: temp28
  REAL(dp), DIMENSION(nbdirs) :: tempb16
  REAL(dp), DIMENSION(nbdirs) :: tempb17
  REAL(dp), DIMENSION(nbdirs) :: tempb18
  REAL(dp), DIMENSION(nbdirs) :: tempb19
  INTEGER :: nbdirs
! initialize output variables
!print *, "TI_dst in: ", TI_dst
! Niayifar and Porte Agel 2015, 2016 (adjusted by Annoni and Thomas for SOWFA match 
! and optimization)
  IF (ti_calculation_method .EQ. 1) THEN
! calculate axial induction based on the Ct value
    CALL CT_TO_AXIAL_IND_FUNC(ct_ust, axial_induction_ust)
! calculate BPA spread parameters Bastankhah and Porte Agel 2014
    beta = 0.5_dp*((1.0_dp+SQRT(1.0_dp-ct_ust))/SQRT(1.0_dp-ct_ust))
    epsilon = 0.2_dp*SQRT(beta)
!print *, "epsilon = ", epsilon
! calculate wake spread for TI calcs
    sigma = k_star_ust*x + rotor_diameter_ust*epsilon
    wake_diameter = 4.0_dp*sigma
!print *, "sigma = ", sigma
! calculate wake overlap ratio
    CALL OVERLAP_AREA_FUNC(deltay, turbine_height, rotor_diameter_dst, &
&                    0.0_dp, wake_height, wake_diameter, wake_overlap)
!print *, "wake_overlap = ", wake_overlap   
! Calculate the turbulence added to the inflow of the downstream turbine by the 
! wake of the upstream turbine
    ti_added = 0.73_dp*axial_induction_ust**0.8325_dp*ti_ust**0.0325_dp*&
&     (x/rotor_diameter_ust)**(-0.32_dp)
!print *, "TI_added = ", TI_added
    rotor_area_dst = 0.25_dp*pi*rotor_diameter_dst**2_dp
! Calculate the total turbulence intensity at the downstream turbine
!sum_of_squares = TI_dst**2 + (TI_added*wake_overlap)**2
! print *, "sum of squares = ", sum_of_squares
!         TI_dst = sqrt(sum_of_squares)
!         !print *, "TI_dst = ", TI_dst
! Niayifar and Porte Agel 2015, 2016
    temp4 = ti_added*wake_overlap/rotor_area_dst
    temp1 = x/rotor_diameter_ust
    temp3 = ti_ust**0.0325_dp
    temp2 = axial_induction_ust**0.8325_dp
    temp0 = SQRT(-ct_ust + 1.0_dp)
    temp = SQRT(-ct_ust + 1.0_dp)
    DO nd=1,nbdirs
      IF (ti_dst_in**2.0_dp + temp4**2.0_dp .EQ. 0.0) THEN
        tempb(nd) = 0.0
      ELSE
        tempb(nd) = ti_dstb(nd)/(2.0*SQRT(ti_dst_in**2.0_dp+temp4**&
&         2.0_dp))
      END IF
      tempb0(nd) = 2.0_dp*temp4*tempb(nd)/rotor_area_dst
      ti_dst_inb(nd) = 2.0_dp*ti_dst_in*tempb(nd)
      ti_addedb(nd) = wake_overlap*tempb0(nd)
      wake_overlapb(nd) = ti_added*tempb0(nd)
      rotor_area_dstb(nd) = -(temp4*tempb0(nd))
      rotor_diameter_dstb(nd) = rotor_diameter_dstb(nd) + pi*0.25_dp*&
&       2_dp*rotor_diameter_dst*rotor_area_dstb(nd)
      tempb1(nd) = 0.73_dp*temp1**(-0.32_dp)*ti_addedb(nd)
      tempb2(nd) = -(0.32_dp*temp1**(-1.32)*temp2*temp3*0.73_dp*&
&       ti_addedb(nd)/rotor_diameter_ust)
      axial_induction_ustb(nd) = temp3*0.8325_dp*axial_induction_ust**(&
&       -0.1675)*tempb1(nd)
      ti_ustb(nd) = temp2*0.0325_dp*ti_ust**(-0.9675)*tempb1(nd)
    END DO
    CALL OVERLAP_AREA_FUNC_BV(deltay, deltayb, turbine_height, &
&                       turbine_heightb, rotor_diameter_dst, &
&                       rotor_diameter_dstb, 0.0_dp, wake_height, &
&                       wake_heightb, wake_diameter, wake_diameterb, &
&                       wake_overlap, wake_overlapb, nbdirs)
    DO nd=1,nbdirs
      sigmab(nd) = 4.0_dp*wake_diameterb(nd)
      xb(nd) = k_star_ust*sigmab(nd) + tempb2(nd)
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + epsilon*sigmab&
&       (nd) - temp1*tempb2(nd)
      k_star_ustb(nd) = k_star_ustb(nd) + x*sigmab(nd)
      epsilonb(nd) = rotor_diameter_ust*sigmab(nd)
      IF (beta .EQ. 0.0) THEN
        betab(nd) = 0.0
      ELSE
        betab(nd) = 0.2_dp*epsilonb(nd)/(2.0*SQRT(beta))
      END IF
      tempb3(nd) = 0.5_dp*betab(nd)/temp0
      IF (.NOT.1.0_dp - ct_ust .EQ. 0.0) ct_ustb(nd) = ct_ustb(nd) + ((&
&         temp+1.0_dp)/(2.0*temp0**2)-1.0/(2.0*temp))*tempb3(nd)
    END DO
    CALL CT_TO_AXIAL_IND_FUNC_BV(ct_ust, ct_ustb, axial_induction_ust, &
&                          axial_induction_ustb, nbdirs)
    DO nd=1,nbdirs
      ti_dstb(nd) = 0.0_8
    END DO
  ELSE IF (ti_calculation_method .EQ. 2) THEN
! calculate axial induction based on the Ct value
    CALL CT_TO_AXIAL_IND_FUNC(ct_ust, axial_induction_ust)
! calculate BPA spread parameters Bastankhah and Porte Agel 2014
    beta = 0.5_dp*((1.0_dp+SQRT(1.0_dp-ct_ust))/SQRT(1.0_dp-ct_ust))
    epsilon = 0.2_dp*SQRT(beta)
! calculate wake spread for TI calcs
    sigma = k_star_ust*x + rotor_diameter_ust*epsilon
    wake_diameter = 4.0_dp*sigma
! calculate wake overlap ratio
    CALL OVERLAP_AREA_FUNC(deltay, turbine_height, rotor_diameter_dst, &
&                    0.0_dp, wake_height, wake_diameter, wake_overlap)
! Calculate the turbulence added to the inflow of the downstream turbine by the 
! wake of the upstream turbine
    ti_added = 0.73_dp*axial_induction_ust**0.8325_dp*ti_ust**0.0325_dp*&
&     (x/rotor_diameter_ust)**(-0.32_dp)
! Calculate the total turbulence intensity at the downstream turbine based on 
! current upstream turbine
    rotor_area_dst = 0.25_dp*pi*rotor_diameter_dst**2_dp
    ti_tmp = SQRT(ti**2.0_dp + (ti_added*(wake_overlap/rotor_area_dst))&
&     **2.0_dp)
! Check if this is the max and use it if it is
    IF (ti_tmp .GT. ti_dst_in) THEN
      DO nd=1,nbdirs
        ti_tmpb(nd) = ti_dstb(nd)
      END DO
      DO nd=1,nbdirs
        ti_dstb(nd) = 0.0_8
      END DO
    ELSE
      DO nd=1,nbdirs
        ti_tmpb(nd) = 0.0_8
      END DO
    END IF
    temp10 = ti_added*wake_overlap/rotor_area_dst
    temp7 = x/rotor_diameter_ust
    temp9 = ti_ust**0.0325_dp
    temp8 = axial_induction_ust**0.8325_dp
    temp6 = SQRT(-ct_ust + 1.0_dp)
    temp5 = SQRT(-ct_ust + 1.0_dp)
    DO nd=1,nbdirs
      IF (ti**2.0_dp + temp10**2.0_dp .EQ. 0.0) THEN
        tempb4(nd) = 0.0
      ELSE
        tempb4(nd) = 2.0_dp*temp10*ti_tmpb(nd)/(2.0*SQRT(ti**2.0_dp+&
&         temp10**2.0_dp)*rotor_area_dst)
      END IF
      ti_addedb(nd) = wake_overlap*tempb4(nd)
      wake_overlapb(nd) = ti_added*tempb4(nd)
      rotor_area_dstb(nd) = -(temp10*tempb4(nd))
      rotor_diameter_dstb(nd) = rotor_diameter_dstb(nd) + pi*0.25_dp*&
&       2_dp*rotor_diameter_dst*rotor_area_dstb(nd)
      tempb5(nd) = 0.73_dp*temp7**(-0.32_dp)*ti_addedb(nd)
      tempb6(nd) = -(0.32_dp*temp7**(-1.32)*temp8*temp9*0.73_dp*&
&       ti_addedb(nd)/rotor_diameter_ust)
      axial_induction_ustb(nd) = temp9*0.8325_dp*axial_induction_ust**(&
&       -0.1675)*tempb5(nd)
      ti_ustb(nd) = temp8*0.0325_dp*ti_ust**(-0.9675)*tempb5(nd)
    END DO
    CALL OVERLAP_AREA_FUNC_BV(deltay, deltayb, turbine_height, &
&                       turbine_heightb, rotor_diameter_dst, &
&                       rotor_diameter_dstb, 0.0_dp, wake_height, &
&                       wake_heightb, wake_diameter, wake_diameterb, &
&                       wake_overlap, wake_overlapb, nbdirs)
    DO nd=1,nbdirs
      sigmab(nd) = 4.0_dp*wake_diameterb(nd)
      xb(nd) = k_star_ust*sigmab(nd) + tempb6(nd)
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + epsilon*sigmab&
&       (nd) - temp7*tempb6(nd)
      k_star_ustb(nd) = k_star_ustb(nd) + x*sigmab(nd)
      epsilonb(nd) = rotor_diameter_ust*sigmab(nd)
      IF (beta .EQ. 0.0) THEN
        betab(nd) = 0.0
      ELSE
        betab(nd) = 0.2_dp*epsilonb(nd)/(2.0*SQRT(beta))
      END IF
      tempb7(nd) = 0.5_dp*betab(nd)/temp6
      IF (.NOT.1.0_dp - ct_ust .EQ. 0.0) ct_ustb(nd) = ct_ustb(nd) + ((&
&         temp5+1.0_dp)/(2.0*temp6**2)-1.0/(2.0*temp5))*tempb7(nd)
    END DO
    CALL CT_TO_AXIAL_IND_FUNC_BV(ct_ust, ct_ustb, axial_induction_ust, &
&                          axial_induction_ustb, nbdirs)
    DO nd=1,nbdirs
      ti_dst_inb(nd) = 0.0_8
    END DO
  ELSE IF (ti_calculation_method .EQ. 3) THEN
! Niayifar and Porte Agel 2015, 2016 with smooth max
! calculate axial induction based on the Ct value
    CALL CT_TO_AXIAL_IND_FUNC(ct_ust, axial_induction_ust)
! calculate BPA spread parameters Bastankhah and Porte Agel 2014
    beta = 0.5_dp*((1.0_dp+SQRT(1.0_dp-ct_ust))/SQRT(1.0_dp-ct_ust))
    epsilon = 0.2_dp*SQRT(beta)
! calculate wake spread for TI calcs
    sigma = k_star_ust*x + rotor_diameter_ust*epsilon
    wake_diameter = 4.0_dp*sigma
!         print *, "sigma, k_star_ust, x, rotor_diameter_ust, epsilon ", sigma, k_star_ust, x, rotor_diameter_ust, epsilon
! print *, "deltay, turbine_height, rotor_diameter_dst, wake_height, wake_diameter", &
!                 & deltay, turbine_height, rotor_diameter_dst, &
!                             wake_height, wake_diameter
! calculate wake overlap ratio
    CALL OVERLAP_AREA_FUNC(deltay, turbine_height, rotor_diameter_dst, &
&                    0.0_dp, wake_height, wake_diameter, wake_overlap)
! Calculate the turbulence added to the inflow of the downstream turbine by the 
! wake of the upstream turbine
    ti_added = 0.73_dp*axial_induction_ust**0.8325_dp*ti_ust**0.0325_dp*&
&     (x/rotor_diameter_ust)**(-0.32_dp)
! Calculate the total turbulence intensity at the downstream turbine based on 
! current upstream turbine
    rotor_area_dst = 0.25_dp*pi*rotor_diameter_dst**2_dp
    ti_tmp = SQRT(ti**2.0_dp + (ti_added*(wake_overlap/rotor_area_dst))&
&     **2.0_dp)
!print *, "TI, TI_added, wake_overlap, rotor_area_dst: ", TI, TI_added, wake_overlap, rotor_area_dst
! Check if this is the max and use it if it is
!if (TI_tmp > TI_dst) then
!    TI_dst = TI_tmp
!end if
!         print *, "before: ", TI_dst, TI_tmp
!         TI_dst_in = TI_dst
!         print *, "after:: ", TI_dst, TI_tmp
! Niayifar and Porte Agel 2015, 2016 using max on area TI ratio
    CALL SMOOTH_MAX_BV(ti_dst_in, ti_dst_inb, ti_tmp, ti_tmpb, ti_dst, &
&                ti_dstb, nbdirs)
    temp16 = ti_added*wake_overlap/rotor_area_dst
    temp13 = x/rotor_diameter_ust
    temp15 = ti_ust**0.0325_dp
    temp14 = axial_induction_ust**0.8325_dp
    temp12 = SQRT(-ct_ust + 1.0_dp)
    temp11 = SQRT(-ct_ust + 1.0_dp)
    DO nd=1,nbdirs
      IF (ti**2.0_dp + temp16**2.0_dp .EQ. 0.0) THEN
        tempb8(nd) = 0.0
      ELSE
        tempb8(nd) = 2.0_dp*temp16*ti_tmpb(nd)/(2.0*SQRT(ti**2.0_dp+&
&         temp16**2.0_dp)*rotor_area_dst)
      END IF
      ti_addedb(nd) = wake_overlap*tempb8(nd)
      wake_overlapb(nd) = ti_added*tempb8(nd)
      rotor_area_dstb(nd) = -(temp16*tempb8(nd))
      rotor_diameter_dstb(nd) = rotor_diameter_dstb(nd) + pi*0.25_dp*&
&       2_dp*rotor_diameter_dst*rotor_area_dstb(nd)
      tempb9(nd) = 0.73_dp*temp13**(-0.32_dp)*ti_addedb(nd)
      tempb10(nd) = -(0.32_dp*temp13**(-1.32)*temp14*temp15*0.73_dp*&
&       ti_addedb(nd)/rotor_diameter_ust)
      axial_induction_ustb(nd) = temp15*0.8325_dp*axial_induction_ust**(&
&       -0.1675)*tempb9(nd)
      ti_ustb(nd) = temp14*0.0325_dp*ti_ust**(-0.9675)*tempb9(nd)
    END DO
    CALL OVERLAP_AREA_FUNC_BV(deltay, deltayb, turbine_height, &
&                       turbine_heightb, rotor_diameter_dst, &
&                       rotor_diameter_dstb, 0.0_dp, wake_height, &
&                       wake_heightb, wake_diameter, wake_diameterb, &
&                       wake_overlap, wake_overlapb, nbdirs)
    DO nd=1,nbdirs
      sigmab(nd) = 4.0_dp*wake_diameterb(nd)
      xb(nd) = k_star_ust*sigmab(nd) + tempb10(nd)
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + epsilon*sigmab&
&       (nd) - temp13*tempb10(nd)
      k_star_ustb(nd) = k_star_ustb(nd) + x*sigmab(nd)
      epsilonb(nd) = rotor_diameter_ust*sigmab(nd)
      IF (beta .EQ. 0.0) THEN
        betab(nd) = 0.0
      ELSE
        betab(nd) = 0.2_dp*epsilonb(nd)/(2.0*SQRT(beta))
      END IF
      tempb11(nd) = 0.5_dp*betab(nd)/temp12
      IF (.NOT.1.0_dp - ct_ust .EQ. 0.0) ct_ustb(nd) = ct_ustb(nd) + ((&
&         temp11+1.0_dp)/(2.0*temp12**2)-1.0/(2.0*temp11))*tempb11(nd)
    END DO
    CALL CT_TO_AXIAL_IND_FUNC_BV(ct_ust, ct_ustb, axial_induction_ust, &
&                          axial_induction_ustb, nbdirs)
    DO nd=1,nbdirs
      ti_dstb(nd) = 0.0_8
    END DO
  ELSE IF (ti_calculation_method .EQ. 4) THEN
! calculate axial induction based on the Ct value
    CALL CT_TO_AXIAL_IND_FUNC(ct_ust, axial_induction_ust)
! calculate BPA spread parameters Bastankhah and Porte Agel 2014
    beta = 0.5_dp*((1.0_dp+SQRT(1.0_dp-ct_ust))/SQRT(1.0_dp-ct_ust))
    epsilon = 0.2_dp*SQRT(beta)
! calculate wake spread for TI calcs
    sigma = k_star_ust*x + rotor_diameter_ust*epsilon
    wake_diameter = 4.0_dp*sigma
! calculate wake overlap ratio
    CALL OVERLAP_AREA_FUNC(deltay, turbine_height, rotor_diameter_dst, &
&                    0.0_dp, wake_height, wake_diameter, wake_overlap)
! Calculate the turbulence added to the inflow of the downstream turbine by the 
! wake of the upstream turbine
    ti_added = 0.73_dp*axial_induction_ust**0.8325_dp*ti_ust**0.0325_dp*&
&     (x/rotor_diameter_ust)**(-0.32_dp)
! Calculate the total turbulence intensity at the downstream turbine based on 
! current upstream turbine
    rotor_area_dst = 0.25_dp*pi*rotor_diameter_dst**2_dp
    ti_area_ratio_tmp = ti_added*(wake_overlap/rotor_area_dst)
! Check if this is the max and use it if it is
    IF (ti_area_ratio_tmp .GT. ti_area_ratio_in) THEN
      DO nd=1,nbdirs
        ti_tmpb(nd) = ti_dstb(nd)
      END DO
      DO nd=1,nbdirs
        ti_dstb(nd) = 0.0_8
      END DO
    ELSE
      DO nd=1,nbdirs
        ti_tmpb(nd) = 0.0_8
      END DO
    END IF
    temp22 = ti_added*wake_overlap/rotor_area_dst
    temp19 = x/rotor_diameter_ust
    temp21 = ti_ust**0.0325_dp
    temp20 = axial_induction_ust**0.8325_dp
    temp18 = SQRT(-ct_ust + 1.0_dp)
    temp17 = SQRT(-ct_ust + 1.0_dp)
    DO nd=1,nbdirs
      IF (ti**2.0_dp + temp22**2.0_dp .EQ. 0.0) THEN
        tempb12(nd) = 0.0
      ELSE
        tempb12(nd) = 2.0_dp*temp22*ti_tmpb(nd)/(2.0*SQRT(ti**2.0_dp+&
&         temp22**2.0_dp)*rotor_area_dst)
      END IF
      ti_addedb(nd) = wake_overlap*tempb12(nd)
      wake_overlapb(nd) = ti_added*tempb12(nd)
      rotor_area_dstb(nd) = -(temp22*tempb12(nd))
      rotor_diameter_dstb(nd) = rotor_diameter_dstb(nd) + pi*0.25_dp*&
&       2_dp*rotor_diameter_dst*rotor_area_dstb(nd)
      tempb13(nd) = 0.73_dp*temp19**(-0.32_dp)*ti_addedb(nd)
      tempb14(nd) = -(0.32_dp*temp19**(-1.32)*temp20*temp21*0.73_dp*&
&       ti_addedb(nd)/rotor_diameter_ust)
      axial_induction_ustb(nd) = temp21*0.8325_dp*axial_induction_ust**(&
&       -0.1675)*tempb13(nd)
      ti_ustb(nd) = temp20*0.0325_dp*ti_ust**(-0.9675)*tempb13(nd)
    END DO
    CALL OVERLAP_AREA_FUNC_BV(deltay, deltayb, turbine_height, &
&                       turbine_heightb, rotor_diameter_dst, &
&                       rotor_diameter_dstb, 0.0_dp, wake_height, &
&                       wake_heightb, wake_diameter, wake_diameterb, &
&                       wake_overlap, wake_overlapb, nbdirs)
    DO nd=1,nbdirs
      sigmab(nd) = 4.0_dp*wake_diameterb(nd)
      xb(nd) = k_star_ust*sigmab(nd) + tempb14(nd)
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + epsilon*sigmab&
&       (nd) - temp19*tempb14(nd)
      k_star_ustb(nd) = k_star_ustb(nd) + x*sigmab(nd)
      epsilonb(nd) = rotor_diameter_ust*sigmab(nd)
      IF (beta .EQ. 0.0) THEN
        betab(nd) = 0.0
      ELSE
        betab(nd) = 0.2_dp*epsilonb(nd)/(2.0*SQRT(beta))
      END IF
      tempb15(nd) = 0.5_dp*betab(nd)/temp18
      IF (.NOT.1.0_dp - ct_ust .EQ. 0.0) ct_ustb(nd) = ct_ustb(nd) + ((&
&         temp17+1.0_dp)/(2.0*temp18**2)-1.0/(2.0*temp17))*tempb15(nd)
    END DO
    CALL CT_TO_AXIAL_IND_FUNC_BV(ct_ust, ct_ustb, axial_induction_ust, &
&                          axial_induction_ustb, nbdirs)
    DO nd=1,nbdirs
      ti_dst_inb(nd) = 0.0_8
    END DO
  ELSE IF (ti_calculation_method .EQ. 5) THEN
! Niayifar and Porte Agel 2015, 2016 using smooth max on area TI ratio
! calculate axial induction based on the Ct value
    CALL CT_TO_AXIAL_IND_FUNC(ct_ust, axial_induction_ust)
! calculate BPA spread parameters Bastankhah and Porte Agel 2014
    beta = 0.5_dp*((1.0_dp+SQRT(1.0_dp-ct_ust))/SQRT(1.0_dp-ct_ust))
    epsilon = 0.2_dp*SQRT(beta)
! calculate wake spread for TI calcs
    sigma = k_star_ust*x + rotor_diameter_ust*epsilon
    wake_diameter = 4.0_dp*sigma
! calculate wake overlap ratio
    CALL OVERLAP_AREA_FUNC(deltay, turbine_height, rotor_diameter_dst, &
&                    0.0_dp, wake_height, wake_diameter, wake_overlap)
! Calculate the turbulence added to the inflow of the downstream turbine by the 
! wake of the upstream turbine
    ti_added = 0.73_dp*axial_induction_ust**0.8325_dp*ti_ust**0.0325_dp*&
&     (x/rotor_diameter_ust)**(-0.32_dp)
! Calculate the total turbulence intensity at the downstream turbine based on 
! current upstream turbine
    rotor_area_dst = 0.25_dp*pi*rotor_diameter_dst**2_dp
    ti_tmp = SQRT(ti**2.0_dp + (ti_added*(wake_overlap/rotor_area_dst))&
&     **2.0_dp)
! Check if this is the max and use it if it is
!         TI_dst_in = TI_dst
!print *, "sigma: ", sigma
! TODO add other TI calculation methods
! wake combination method error 
    CALL SMOOTH_MAX_BV(ti_dst_in, ti_dst_inb, ti_tmp, ti_tmpb, ti_dst, &
&                ti_dstb, nbdirs)
    temp28 = ti_added*wake_overlap/rotor_area_dst
    temp25 = x/rotor_diameter_ust
    temp27 = ti_ust**0.0325_dp
    temp26 = axial_induction_ust**0.8325_dp
    temp24 = SQRT(-ct_ust + 1.0_dp)
    temp23 = SQRT(-ct_ust + 1.0_dp)
    DO nd=1,nbdirs
      IF (ti**2.0_dp + temp28**2.0_dp .EQ. 0.0) THEN
        tempb16(nd) = 0.0
      ELSE
        tempb16(nd) = 2.0_dp*temp28*ti_tmpb(nd)/(2.0*SQRT(ti**2.0_dp+&
&         temp28**2.0_dp)*rotor_area_dst)
      END IF
      ti_addedb(nd) = wake_overlap*tempb16(nd)
      wake_overlapb(nd) = ti_added*tempb16(nd)
      rotor_area_dstb(nd) = -(temp28*tempb16(nd))
      rotor_diameter_dstb(nd) = rotor_diameter_dstb(nd) + pi*0.25_dp*&
&       2_dp*rotor_diameter_dst*rotor_area_dstb(nd)
      tempb17(nd) = 0.73_dp*temp25**(-0.32_dp)*ti_addedb(nd)
      tempb18(nd) = -(0.32_dp*temp25**(-1.32)*temp26*temp27*0.73_dp*&
&       ti_addedb(nd)/rotor_diameter_ust)
      axial_induction_ustb(nd) = temp27*0.8325_dp*axial_induction_ust**(&
&       -0.1675)*tempb17(nd)
      ti_ustb(nd) = temp26*0.0325_dp*ti_ust**(-0.9675)*tempb17(nd)
    END DO
    CALL OVERLAP_AREA_FUNC_BV(deltay, deltayb, turbine_height, &
&                       turbine_heightb, rotor_diameter_dst, &
&                       rotor_diameter_dstb, 0.0_dp, wake_height, &
&                       wake_heightb, wake_diameter, wake_diameterb, &
&                       wake_overlap, wake_overlapb, nbdirs)
    DO nd=1,nbdirs
      sigmab(nd) = 4.0_dp*wake_diameterb(nd)
      xb(nd) = k_star_ust*sigmab(nd) + tempb18(nd)
      rotor_diameter_ustb(nd) = rotor_diameter_ustb(nd) + epsilon*sigmab&
&       (nd) - temp25*tempb18(nd)
      k_star_ustb(nd) = k_star_ustb(nd) + x*sigmab(nd)
      epsilonb(nd) = rotor_diameter_ust*sigmab(nd)
      IF (beta .EQ. 0.0) THEN
        betab(nd) = 0.0
      ELSE
        betab(nd) = 0.2_dp*epsilonb(nd)/(2.0*SQRT(beta))
      END IF
      tempb19(nd) = 0.5_dp*betab(nd)/temp24
      IF (.NOT.1.0_dp - ct_ust .EQ. 0.0) ct_ustb(nd) = ct_ustb(nd) + ((&
&         temp23+1.0_dp)/(2.0*temp24**2)-1.0/(2.0*temp23))*tempb19(nd)
    END DO
    CALL CT_TO_AXIAL_IND_FUNC_BV(ct_ust, ct_ustb, axial_induction_ust, &
&                          axial_induction_ustb, nbdirs)
    DO nd=1,nbdirs
      ti_dstb(nd) = 0.0_8
    END DO
  ELSE
    print *, "random stop"
    STOP
  END IF
  DO nd=1,nbdirs
    ti_dst_inb(nd) = ti_dst_inb(nd) + ti_dstb(nd)
  END DO
END SUBROUTINE ADDED_TI_FUNC_BV

!  Differentiation of overlap_area_func in reverse (adjoint) mode:
!   gradient     of useful results: rotor_diameter turbine_z wake_center_z
!                wake_overlap
!   with respect to varying inputs: wake_diameter rotor_diameter
!                turbine_y turbine_z wake_center_z
! calculates the overlap area between a given wake and a rotor area
SUBROUTINE OVERLAP_AREA_FUNC_BV(turbine_y, turbine_yb, turbine_z, &
& turbine_zb, rotor_diameter, rotor_diameterb, wake_center_y, &
& wake_center_z, wake_center_zb, wake_diameter, wake_diameterb, &
& wake_overlap, wake_overlapb, nbdirs)
  !USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: turbine_y, turbine_z, rotor_diameter
  REAL(dp), DIMENSION(nbdirs) :: turbine_yb, turbine_zb, &
& rotor_diameterb
  REAL(dp), INTENT(IN) :: wake_center_y, wake_center_z, wake_diameter
  REAL(dp), DIMENSION(nbdirs) :: wake_center_zb, wake_diameterb
! out    
  REAL(dp) :: wake_overlap
  REAL(dp), DIMENSION(nbdirs) :: wake_overlapb
! local
  REAL(dp), PARAMETER :: pi=3.141592653589793_dp, tol=0.000001_dp
  REAL(dp) :: ovdyd, ovr, ovrr, ovl, ovz
  REAL(dp), DIMENSION(nbdirs) :: ovdydb, ovrb, ovrrb, ovlb, ovzb
! load intrinsic functions
  INTRINSIC ACOS, SQRT
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp), DIMENSION(nbdirs) :: tempb2
  REAL(dp), DIMENSION(nbdirs) :: tempb3
  INTEGER :: branch
  INTEGER :: nbdirs
! distance between wake center and rotor center
  IF (wake_center_z .GT. turbine_z + tol .OR. wake_center_z .LT. &
&     turbine_z - tol) THEN
    ovdyd = SQRT((wake_center_y-turbine_y)**2_dp + (wake_center_z-&
&     turbine_z)**2_dp)
    CALL PUSHCONTROL2B(0)
  ELSE IF (wake_center_y .GT. turbine_y) THEN
! potential source of gradient issues, abs() did not cause a problem in FLORIS
    ovdyd = wake_center_y - turbine_y
    CALL PUSHCONTROL2B(1)
  ELSE IF (turbine_y .GT. wake_center_y) THEN
    ovdyd = turbine_y - wake_center_y
    CALL PUSHCONTROL2B(2)
  ELSE
    ovdyd = 0.0_dp
    CALL PUSHCONTROL2B(3)
  END IF
!print *, "OVdYd: ", OVdYd
! find rotor radius
  ovr = rotor_diameter/2.0_dp
!print *, "OVr: ", OVr
! find wake radius
  ovrr = wake_diameter/2.0_dp
!print *, "OVRR: ", OVRR
! make sure the distance from wake center to turbine hub is positive
! OVdYd = abs(OVdYd) !!! commented out since change to 2D distance (y,z) will always be positive
! calculate the distance from the wake center to the line perpendicular to the 
! line between the two circle intersection points
!if (OVdYd >= 0.0_dp + tol) then ! check case to avoid division by zero
  IF (ovdyd .GT. 0.0_dp + tol) THEN
! check case to avoid division by zero
    ovl = (-(ovr*ovr)+ovrr*ovrr+ovdyd*ovdyd)/(2.0_dp*ovdyd)
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    ovl = 0.0_dp
  END IF
  ovz = ovrr*ovrr - ovl*ovl
! Finish calculating the distance from the intersection line to the outer edge of the wake
!if (OVz > 0.0_dp + tol) then
  IF (ovz .GT. 0.0_dp + tol) THEN
    CALL PUSHREAL8(ovz)
    ovz = SQRT(ovz)
    CALL PUSHCONTROL1B(0)
  ELSE
    ovz = 0.0_dp
    CALL PUSHCONTROL1B(1)
  END IF
!print *, "OVRR, OVL, OVRR, OVr, OVdYd, OVz ", OVRR, OVL, OVRR, OVr, OVdYd, OVz
  IF (ovdyd .LT. ovr + ovrr) THEN
! if the rotor overlaps the wake
!print *, "OVL: ", OVL
    IF (ovl .LT. ovrr .AND. ovdyd - ovl .LT. ovr) THEN
!         if (OVdYd > 0.0_dp + tol) then
!         if ((OVdYd > 0.0_dp) .and. (OVdYd > (OVRR - OVr))) then
! print *, "acos(OVL/OVRR), acos((OVdYd-OVL)/OVr), OVRR, OVL, OVr, OVdYd, OVL/OVRR, (OVdYd-OVL)/OVr ", &
!     & acos(OVL/OVRR), acos((OVdYd-OVL)/OVr), OVRR, OVL, OVr, OVdYd, OVL/OVRR, (OVdYd-OVL)/OVr
      wake_overlap = ovrr*ovrr*ACOS(ovl/ovrr) + ovr*ovr*ACOS((ovdyd-ovl)&
&       /ovr) - ovdyd*ovz
      CALL PUSHCONTROL2B(0)
    ELSE IF (ovrr .GT. ovr) THEN
      wake_overlap = pi*ovr*ovr
!print *, "wake ovl: ", wake_overlap
      CALL PUSHCONTROL2B(1)
    ELSE
      wake_overlap = pi*ovrr*ovrr
      CALL PUSHCONTROL2B(2)
    END IF
  ELSE
    wake_overlap = 0.0_dp
    CALL PUSHCONTROL2B(3)
  END IF
  IF (wake_overlap/(pi*ovr**2) .GT. 1.0_dp + tol .OR. wake_overlap/(pi*&
&     ovrr**2) .GT. 1.0_dp + tol) THEN
    STOP
  ELSE
    CALL POPCONTROL2B(branch)
    IF (branch .LT. 2) THEN
      IF (branch .EQ. 0) THEN
        temp = ovl/ovrr
        temp0 = (ovdyd-ovl)/ovr
        DO nd=1,nbdirs
          IF (temp .EQ. 1.0 .OR. temp .EQ. (-1.0)) THEN
            tempb2(nd) = 0.0
          ELSE
            tempb2(nd) = -(ovrr*wake_overlapb(nd)/SQRT(1.0-temp**2))
          END IF
          IF (temp0 .EQ. 1.0 .OR. temp0 .EQ. (-1.0)) THEN
            tempb3(nd) = 0.0
          ELSE
            tempb3(nd) = -(ovr*wake_overlapb(nd)/SQRT(1.0-temp0**2))
          END IF
          ovrrb(nd) = ACOS(temp)*2*ovrr*wake_overlapb(nd) - temp*tempb2(&
&           nd)
          ovlb(nd) = tempb2(nd) - tempb3(nd)
          ovrb(nd) = ACOS(temp0)*2*ovr*wake_overlapb(nd) - temp0*tempb3(&
&           nd)
          ovdydb(nd) = tempb3(nd) - ovz*wake_overlapb(nd)
          ovzb(nd) = -(ovdyd*wake_overlapb(nd))
        END DO
        GOTO 100
      ELSE
        DO nd=1,nbdirs
          ovrb(nd) = pi*2*ovr*wake_overlapb(nd)
        END DO
        DO nd=1,nbdirs
          ovrrb(nd) = 0.0_8
        END DO
      END IF
    ELSE IF (branch .EQ. 2) THEN
      DO nd=1,nbdirs
        ovrrb(nd) = pi*2*ovrr*wake_overlapb(nd)
      END DO
      DO nd=1,nbdirs
        ovrb(nd) = 0.0_8
      END DO
    ELSE
      DO nd=1,nbdirs
        ovdydb(nd) = 0.0_8
        ovlb(nd) = 0.0_8
        ovrb(nd) = 0.0_8
        ovrrb(nd) = 0.0_8
        ovzb(nd) = 0.0_8
      END DO
      GOTO 100
    END IF
    DO nd=1,nbdirs
      ovdydb(nd) = 0.0_8
      ovlb(nd) = 0.0_8
      ovzb(nd) = 0.0_8
    END DO
 100 CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(ovz)
      DO nd=1,nbdirs
        IF (ovz .EQ. 0.0) THEN
          ovzb(nd) = 0.0
        ELSE
          ovzb(nd) = ovzb(nd)/(2.0*SQRT(ovz))
        END IF
      END DO
    ELSE
      DO nd=1,nbdirs
        ovzb(nd) = 0.0_8
      END DO
    END IF
    DO nd=1,nbdirs
      ovrrb(nd) = ovrrb(nd) + 2*ovrr*ovzb(nd)
      ovlb(nd) = ovlb(nd) - 2*ovl*ovzb(nd)
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DO nd=1,nbdirs
        tempb1(nd) = ovlb(nd)/(2.0_dp*ovdyd)
        ovrrb(nd) = ovrrb(nd) + 2*ovrr*tempb1(nd)
        ovrb(nd) = ovrb(nd) - 2*ovr*tempb1(nd)
        ovdydb(nd) = ovdydb(nd) + (2*ovdyd-(ovrr**2-ovr**2+ovdyd**2)/&
&         ovdyd)*tempb1(nd)
      END DO
    END IF
    DO nd=1,nbdirs
      wake_diameterb(nd) = ovrrb(nd)/2.0_dp
      rotor_diameterb(nd) = rotor_diameterb(nd) + ovrb(nd)/2.0_dp
    END DO
    CALL POPCONTROL2B(branch)
    IF (branch .LT. 2) THEN
      IF (branch .EQ. 0) THEN
        DO nd=1,nbdirs
          IF ((wake_center_y-turbine_y)**2_dp + (wake_center_z-turbine_z&
&             )**2_dp .EQ. 0.0) THEN
            tempb(nd) = 0.0
          ELSE
            tempb(nd) = ovdydb(nd)/(2.0*SQRT((wake_center_y-turbine_y)**&
&             2_dp+(wake_center_z-turbine_z)**2_dp))
          END IF
          tempb0(nd) = 2_dp*(wake_center_z-turbine_z)*tempb(nd)
          turbine_yb(nd) = -(2_dp*(wake_center_y-turbine_y)*tempb(nd))
          wake_center_zb(nd) = wake_center_zb(nd) + tempb0(nd)
          turbine_zb(nd) = turbine_zb(nd) - tempb0(nd)
        END DO
      ELSE
        DO nd=1,nbdirs
          turbine_yb(nd) = -ovdydb(nd)
        END DO
      END IF
    ELSE IF (branch .EQ. 2) THEN
      DO nd=1,nbdirs
        turbine_yb(nd) = ovdydb(nd)
      END DO
    ELSE
      DO nd=1,nbdirs
        turbine_yb(nd) = 0.0_8
      END DO
    END IF
  END IF
END SUBROUTINE OVERLAP_AREA_FUNC_BV

!  Differentiation of k_star_func in reverse (adjoint) mode:
!   gradient     of useful results: k_star_ust ti_ust
!   with respect to varying inputs: ti_ust
! compute wake spread parameter based on local turbulence intensity
SUBROUTINE K_STAR_FUNC_BV(ti_ust, ti_ustb, k_star_ust, k_star_ustb, &
& nbdirs)
  !USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: ti_ust
  REAL(dp), DIMENSION(nbdirs) :: ti_ustb
! out  
  REAL(dp) :: k_star_ust
  REAL(dp), DIMENSION(nbdirs) :: k_star_ustb
! calculate wake spread parameter from Niayifar and Porte Agel (2015, 2016)
  INTEGER :: nd
  INTEGER :: nbdirs
  DO nd=1,nbdirs
    ti_ustb(nd) = ti_ustb(nd) + 0.3837*k_star_ustb(nd)
  END DO
END SUBROUTINE K_STAR_FUNC_BV

!  Differentiation of ct_to_axial_ind_func in reverse (adjoint) mode:
!   gradient     of useful results: axial_induction ct
!   with respect to varying inputs: ct
! calculate axial induction from Ct
SUBROUTINE CT_TO_AXIAL_IND_FUNC_BV(ct, ctb, axial_induction, &
& axial_inductionb, nbdirs)
  !USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: ct
  REAL(dp), DIMENSION(nbdirs) :: ctb
! out
  REAL(dp) :: axial_induction
  REAL(dp), DIMENSION(nbdirs) :: axial_inductionb
  INTRINSIC SQRT
  INTEGER :: nd
  INTEGER :: nbdirs
! initialize axial induction to zero
! calculate axial induction
  IF (ct .GT. 0.96) THEN
    DO nd=1,nbdirs
      IF (.NOT.0.0203_dp - 0.6427_dp*(0.889_dp-ct) .EQ. 0.0) ctb(nd) = &
&         ctb(nd) + 0.6427_dp*axial_inductionb(nd)/(2.0*SQRT(0.0203_dp-&
&         0.6427_dp*(0.889_dp-ct)))
    END DO
  ELSE
    DO nd=1,nbdirs
      IF (.NOT.1.0_dp - ct .EQ. 0.0) ctb(nd) = ctb(nd) + 0.5_dp*&
&         axial_inductionb(nd)/(2.0*SQRT(1.0_dp-ct))
    END DO
  END IF
END SUBROUTINE CT_TO_AXIAL_IND_FUNC_BV

!  Differentiation of wind_shear_func in reverse (adjoint) mode:
!   gradient     of useful results: adjusted_wind_speed
!   with respect to varying inputs: point_z u_ref
! adjust wind speed for wind shear
SUBROUTINE WIND_SHEAR_FUNC_BV(point_z, point_zb, u_ref, u_refb, z_ref, &
& z_0, shear_exp, adjusted_wind_speed, adjusted_wind_speedb, nbdirs)
  !USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: point_z, u_ref, z_ref, z_0, shear_exp
  REAL(dp), DIMENSION(nbdirs) :: point_zb, u_refb
! out
  REAL(dp) :: adjusted_wind_speed
  REAL(dp), DIMENSION(nbdirs) :: adjusted_wind_speedb
  REAL(dp) :: temp
  INTEGER :: nd
  INTEGER :: nbdirs
! initialize adjusted wind speed to zero
! check that the point of interest is above ground level
  IF (point_z .GE. z_0) THEN
    temp = (point_z-z_0)/(z_ref-z_0)
    DO nd=1,nbdirs
      u_refb(nd) = temp**shear_exp*adjusted_wind_speedb(nd)
      IF (temp .LE. 0.0 .AND. (shear_exp .EQ. 0.0 .OR. shear_exp .NE. &
&         INT(shear_exp))) THEN
        point_zb(nd) = 0.0
      ELSE
        point_zb(nd) = shear_exp*temp**(shear_exp-1)*u_ref*&
&         adjusted_wind_speedb(nd)/(z_ref-z_0)
      END IF
    END DO
  ELSE
    DO nd=1,nbdirs
      point_zb(nd) = 0.0_8
      u_refb(nd) = 0.0_8
    END DO
  END IF
END SUBROUTINE WIND_SHEAR_FUNC_BV

!  Differentiation of discontinuity_point_func in reverse (adjoint) mode:
!   gradient     of useful results: yaw discontinuity_point ky
!                kz rotor_diameter x0 ct
!   with respect to varying inputs: yaw ky kz rotor_diameter x0
!                ct
! calculate the point where the Bastankhah and Porte Agel wake model becomes undefined
SUBROUTINE DISCONTINUITY_POINT_FUNC_BV(x0, x0b, rotor_diameter, &
& rotor_diameterb, ky, kyb, kz, kzb, yaw, yawb, ct, ctb, &
& discontinuity_point, discontinuity_pointb, nbdirs)
  !USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: x0, rotor_diameter, ky, kz, yaw, ct
  REAL(dp), DIMENSION(nbdirs) :: x0b, rotor_diameterb, kyb, kzb, yawb&
& , ctb
! local
  REAL(dp) :: a, b, c
  REAL(dp), DIMENSION(nbdirs) :: ab, bb, cb
! out
  REAL(dp) :: discontinuity_point
  REAL(dp), DIMENSION(nbdirs) :: discontinuity_pointb
  INTRINSIC COS, SQRT
  REAL(dp) :: temp
  REAL(dp) :: temp0
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  REAL(dp), DIMENSION(nbdirs) :: tempb1
  REAL(dp), DIMENSION(nbdirs) :: tempb2
  INTEGER :: nbdirs
! for clarity, break out the terms in the equation
  a = ky + kz*COS(yaw)
  b = 4.0_dp*ky*kz*COS(yaw)*(ct-1.0_dp)
  c = 2.0_dp*SQRT(8.0_dp)*ky*kz
! distance from rotor to the last point where the wake model is undefined
  temp0 = a**2 - b
  temp = SQRT(temp0)
  DO nd=1,nbdirs
    tempb(nd) = rotor_diameter*discontinuity_pointb(nd)/c
    tempb0(nd) = (a-temp)*discontinuity_pointb(nd)/c
    x0b(nd) = x0b(nd) + discontinuity_pointb(nd)
    IF (temp0 .EQ. 0.0) THEN
      ab(nd) = tempb(nd)
    ELSE
      ab(nd) = (1.0_8-2*a/(2.0*temp))*tempb(nd)
    END IF
    IF (temp0 .EQ. 0.0) THEN
      bb(nd) = 0.0
    ELSE
      bb(nd) = tempb(nd)/(2.0*temp)
    END IF
    rotor_diameterb(nd) = rotor_diameterb(nd) + tempb0(nd)
    cb(nd) = -(rotor_diameter*tempb0(nd)/c)
    tempb1(nd) = SQRT(8.0_dp)*2.0_dp*cb(nd)
    tempb2(nd) = 4.0_dp*COS(yaw)*bb(nd)
    kyb(nd) = kyb(nd) + (ct-1.0_dp)*kz*tempb2(nd) + ab(nd) + kz*tempb1(&
&     nd)
    kzb(nd) = kzb(nd) + (ct-1.0_dp)*ky*tempb2(nd) + COS(yaw)*ab(nd) + ky&
&     *tempb1(nd)
    ctb(nd) = ctb(nd) + ky*kz*tempb2(nd)
    yawb(nd) = yawb(nd) - kz*SIN(yaw)*ab(nd) - ky*kz*(ct-1.0_dp)*4.0_dp*&
&     SIN(yaw)*bb(nd)
  END DO
END SUBROUTINE DISCONTINUITY_POINT_FUNC_BV

!  Differentiation of smooth_max in reverse (adjoint) mode:
!   gradient     of useful results: g
!   with respect to varying inputs: x y
SUBROUTINE SMOOTH_MAX_BV(x, xb, y, yb, g, gb, nbdirs)
  !USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
!     print *, "g2 = ", g
!     print *, "g is ", g
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: x, y
  REAL(dp), DIMENSION(nbdirs) :: xb, yb
! out
  REAL(dp) :: g
  REAL(dp), DIMENSION(nbdirs) :: gb
! local
  REAL(dp) :: s
  INTRINSIC LOG, EXP
  REAL(dp) :: temp
  REAL(dp) :: temp0
  REAL(dp) :: temp1
  INTEGER :: nd
  REAL(dp), DIMENSION(nbdirs) :: tempb
  REAL(dp), DIMENSION(nbdirs) :: tempb0
  INTEGER :: nbdirs
  s = 100.0_dp
!     g = (log(exp(s*x) + exp(s*y)))/s
!     print *, "g1 = ", g
  temp = EXP(s*x) + EXP(s*y)
  temp1 = EXP(s*x)
  temp0 = EXP(s*y)
  DO nd=1,nbdirs
    tempb(nd) = gb(nd)/temp
    tempb0(nd) = -((x*temp1+y*temp0)*tempb(nd)/temp)
    xb(nd) = EXP(s*x)*s*tempb0(nd) + (EXP(s*x)*x*s+temp1)*tempb(nd)
    yb(nd) = EXP(s*y)*s*tempb0(nd) + (EXP(s*y)*y*s+temp0)*tempb(nd)
  END DO
END SUBROUTINE SMOOTH_MAX_BV

!  Differentiation of interpolation in reverse (adjoint) mode:
!   gradient     of useful results: yval xval
!   with respect to varying inputs: yval xval
SUBROUTINE INTERPOLATION_BV(npoints, interp_type, x, y, xval, xvalb, &
& yval, yvalb, nbdirs)
  !USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
!     print *, "yval = ", yval
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  INTEGER, INTENT(IN) :: npoints, interp_type
  REAL(dp), DIMENSION(npoints), INTENT(IN) :: x, y
  REAL(dp), INTENT(IN) :: xval
  REAL(dp), DIMENSION(nbdirs) :: xvalb
! local
  INTEGER :: idx
  REAL(dp) :: x0, x1, y0, dy0, y1, dy1
! out
  REAL(dp) :: yval
  REAL(dp), DIMENSION(nbdirs) :: yvalb
!     print *, "in interpolation"
  INTEGER :: nd
  INTEGER :: nbdirs
  IF (xval .LT. x(1)) THEN
    DO nd=1,nbdirs
      yvalb(nd) = 0.0_8
    END DO
  ELSE IF (xval .GT. x(npoints)) THEN
    DO nd=1,nbdirs
      yvalb(nd) = 0.0_8
    END DO
  ELSE
    idx = 1
    DO WHILE (xval .GT. x(idx) .AND. idx .LE. npoints)
      idx = idx + 1
    END DO
    idx = idx - 1
    x0 = x(idx)
    x1 = x(idx+1)
    y0 = y(idx)
    y1 = y(idx+1)
! Hermite cubic piecewise spline interpolation
    IF (interp_type .EQ. 0) THEN
! approximate derivative at left end of interval
      IF (idx .EQ. 1) THEN
        dy0 = 0.0_dp
      ELSE
        dy0 = (y(idx)-y(idx-1))/(x(idx)-x(idx-1))
      END IF
! approximate derivative at the right end of interval
      IF (idx .GE. npoints - 1) THEN
        dy1 = 0.0_dp
      ELSE
        dy1 = (y(idx+2)-y(idx+1))/(x(idx+2)-x(idx+1))
      END IF
      CALL HERMITE_SPLINE_BV(xval, xvalb, x0, x1, y0, dy0, y1, dy1, yval&
&                      , yvalb, nbdirs)
      DO nd=1,nbdirs
        yvalb(nd) = 0.0_8
      END DO
    ELSE IF (interp_type .EQ. 1) THEN
      DO nd=1,nbdirs
        xvalb(nd) = xvalb(nd) + (y1-y0)*yvalb(nd)/(x1-x0)
      END DO
      DO nd=1,nbdirs
        yvalb(nd) = 0.0_8
      END DO
    END IF
  END IF
END SUBROUTINE INTERPOLATION_BV

!  Differentiation of hermite_spline in reverse (adjoint) mode:
!   gradient     of useful results: x y
!   with respect to varying inputs: x
SUBROUTINE HERMITE_SPLINE_BV(x, xb, x0, x1, y0, dy0, y1, dy1, y, yb, &
& nbdirs)
  !USE DIFFSIZES
!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
!dy_dx = c3*3*x**2 + c2*2*x + c1
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  REAL(dp), INTENT(IN) :: x, x0, x1, y0, dy0, y1, dy1
  REAL(dp), DIMENSION(nbdirs) :: xb
! out
!, dy_dx
  REAL(dp) :: y
  REAL(dp), DIMENSION(nbdirs) :: yb
! local
  REAL(dp) :: c3, c2, c1, c0
  INTEGER :: nd
  INTEGER :: nbdirs
! initialize coefficients for parametric cubic spline
  c3 = 2.0_dp*y1/(x0**3-3.0_dp*x0**2*x1+3.0_dp*x0*x1**2-x1**3) - 2.0_dp*&
&   y0/(x0**3-3.0_dp*x0**2*x1+3.0_dp*x0*x1**2-x1**3) + dy0/(x0**2-2.0_dp&
&   *x0*x1+x1**2) + dy1/(x0**2-2.0_dp*x0*x1+x1**2)
  c2 = 3.0_dp*y0*(x0+x1)/(x0**3-3.0_dp*x0**2*x1+3.0_dp*x0*x1**2-x1**3) -&
&   dy1*(2.0_dp*x0+x1)/(x0**2-2.0_dp*x0*x1+x1**2) - dy0*(x0+2.0_dp*x1)/(&
&   x0**2-2.0_dp*x0*x1+x1**2) - 3.0_dp*y1*(x0+x1)/(x0**3-3.0_dp*x0**2*x1&
&   +3.0_dp*x0*x1**2-x1**3)
  c1 = dy0*(x1**2+2.0_dp*x0*x1)/(x0**2-2.0_dp*x0*x1+x1**2) + dy1*(x0**2+&
&   2.0_dp*x1*x0)/(x0**2-2.0_dp*x0*x1+x1**2) - 6.0_dp*x0*x1*y0/(x0**3-&
&   3.0_dp*x0**2*x1+3.0_dp*x0*x1**2-x1**3) + 6.0_dp*x0*x1*y1/(x0**3-&
&   3.0_dp*x0**2*x1+3.0_dp*x0*x1**2-x1**3)
!    print *, 'c3 = ', c3
!    print *, 'c2 = ', c2
!    print *, 'c1 = ', c1
!    print *, 'c0 = ', c0
! Solve for y and dy values at the given point
  DO nd=1,nbdirs
    xb(nd) = xb(nd) + (c1+c2*2*x+c3*3*x**2)*yb(nd)
  END DO
END SUBROUTINE HERMITE_SPLINE_BV
!    yd, n = _checkIfFloat(yd)
! 
!     y1 = (1-pct_offset)*ymax
!     y2 = (1+pct_offset)*ymax
! 
!     dy1 = (1-pct_offset)
!     dy2 = (1+pct_offset)
! 
!     if (maxmin == 1) then
!         f1 = y1
!         f2 = ymax
!         g1 = 1.0_dp
!         g2 = 0.0_dp
!         if (yd .ge. y2) then
!             idx_constant = False
!         else
!             idx_constant = True
!         end if
! 
!         df1 = dy1
!         df2 = 1.0_dp
! 
! 
!     else if (maxmin == 0) then
!         f1 = ymax
!         f2 = y2
!         g1 = 0.0_dp
!         g2 = 1.0_dp
!         if (yd .ge. y1) then
!             idx_constant = False
!         else
!             idx_constant = True
!         end if
! 
!         df1 = 1.0_dp
!         df2 = dy2
!         
!     end if
! 
!     f = CubicSplineSegment(y1, y2, f1, f2, g1, g2)
! 
!     # main region
!     ya = np.copy(yd)
!     if dyd is None:
!         dya_dyd = np.ones_like(yd)
!     else:
!         dya_dyd = np.copy(dyd)
! 
!     dya_dymax = np.zeros_like(ya)
! 
!     # cubic spline region
!     idx = np.logical_and(yd > y1, yd < y2)
!     ya[idx] = f.eval(yd[idx])
!     dya_dyd[idx] = f.eval_deriv(yd[idx])
!     dya_dymax[idx] = f.eval_deriv_params(yd[idx], dy1, dy2, df1, df2, 0.0, 0.0)
! 
!     # constant region
!     ya[idx_constant] = ymax
!     dya_dyd[idx_constant] = 0.0
!     dya_dymax[idx_constant] = 1.0
! 
!     if n == 1:
!         ya = ya[0]
!         dya_dyd = dya_dyd[0]
!         dya_dymax = dya_dymax[0]
! 
! 
!     return ya, dya_dyd, dya_dymax
! 
! 
! def smooth_max(yd, ymax, pct_offset=0.01, dyd=None):
!     """array max, uses cubic spline to smoothly transition.  derivatives with respect to array and max value.
!     width of transition can be controlled, and chain rules for differentiation"""
!     return _smooth_maxmin(yd, ymax, 'max', pct_offset, dyd)
! 
! 
! def smooth_min(yd, ymin, pct_offset=0.01, dyd=None):
!     """array min, uses cubic spline to smoothly transition.  derivatives with respect to array and min value.
!     width of transition can be controlled, and chain rules for differentiation"""
!     return _smooth_maxmin(yd, ymin, 'min', pct_offset, dyd)
! 

